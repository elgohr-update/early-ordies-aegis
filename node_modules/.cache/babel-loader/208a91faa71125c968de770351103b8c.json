{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar store_1 = require(\"../store\");\nvar errors_1 = require(\"../helpers/errors\");\nvar getWallet_1 = __importDefault(require(\"./getWallet\"));\nvar constants_1 = require(\"../constants\");\nvar transfer_1 = __importDefault(require(\"./transfer\"));\nvar utils_1 = require(\"../helpers/utils\");\nvar operator_1 = require(\"../services/operator\");\nvar syncWallet_1 = require(\"../wallet/syncWallet\");\nvar swaps_1 = require(\"../services/swaps\");\nfunction addOrder(config) {\n  return __awaiter(this, void 0, void 0, function () {\n    var nonce, totalPrice, _a, creditAmount, debitAmount, _b, creditToken, debitToken, _c, creditWallet, debitWallet, fundAmount, creditWalletBalance, _d, creditActiveStateSignatures, creditBalanceSignatures, debitActiveStateSignatures, debitBalanceSignatures, fulfillmentActiveStateSignatures, swapPayload_1, e_1, _e, creditWallet, debitWallet;\n    return __generator(this, function (_f) {\n      switch (_f.label) {\n        case 0:\n          if (!store_1.store.swapWallets.has(config.address)) {\n            return [2, Promise.reject(new errors_1.NCError(errors_1.NCErrorCode.NO_TRADING_SETUP, 'Please make sure setupTrading() is called before adding orders'))];\n          }\n          nonce = utils_1.generateRandomNonce();\n          totalPrice = config.amount.multipliedBy(config.price);\n          _a = config.orderType === 'BUY' ? {\n            creditAmount: config.amount,\n            debitAmount: totalPrice\n          } : {\n            creditAmount: totalPrice,\n            debitAmount: config.amount\n          }, creditAmount = _a.creditAmount, debitAmount = _a.debitAmount;\n          creditAmount = creditAmount.shiftedBy(18);\n          debitAmount = debitAmount.shiftedBy(18);\n          _b = config.orderType === 'BUY' ? {\n            creditToken: config.baseTokenAddress,\n            debitToken: config.quoteTokenAddress\n          } : {\n            creditToken: config.quoteTokenAddress,\n            debitToken: config.baseTokenAddress\n          }, creditToken = _b.creditToken, debitToken = _b.debitToken;\n          _f.label = 1;\n        case 1:\n          _f.trys.push([1, 14,, 21]);\n          return [4, getAvailableSwapWallets(config.address, creditToken, debitToken)];\n        case 2:\n          _c = _f.sent(), creditWallet = _c.creditWallet, debitWallet = _c.debitWallet;\n          return [4, creditWallet.currentEon.finalizeAndHarvest()];\n        case 3:\n          _f.sent();\n          fundAmount = debitAmount.minus(debitWallet.currentEon.balance);\n          if (!fundAmount.gt(constants_1.BN_ZERO)) return [3, 5];\n          return [4, transfer_1.default({\n            amount: fundAmount,\n            from: config.address,\n            to: debitWallet.address,\n            token: debitToken\n          })];\n        case 4:\n          _f.sent();\n          return [3, 7];\n        case 5:\n          if (!fundAmount.lt(constants_1.BN_ZERO)) return [3, 7];\n          return [4, transfer_1.default({\n            amount: fundAmount.abs(),\n            from: debitWallet.address,\n            to: config.address,\n            token: debitToken\n          })];\n        case 6:\n          _f.sent();\n          _f.label = 7;\n        case 7:\n          creditWalletBalance = creditWallet.currentEon.balance;\n          if (!creditWalletBalance.gt(constants_1.BN_ZERO)) return [3, 9];\n          return [4, transfer_1.default({\n            amount: creditWalletBalance,\n            from: creditWallet.address,\n            to: config.address,\n            token: creditToken\n          })];\n        case 8:\n          _f.sent();\n          _f.label = 9;\n        case 9:\n          return [4, swaps_1.createSwapOrderSignatures({\n            creditWallet: creditWallet,\n            debitWallet: debitWallet,\n            creditAmount: creditAmount,\n            debitAmount: debitAmount,\n            nonce: nonce\n          })];\n        case 10:\n          _d = _f.sent(), creditActiveStateSignatures = _d.creditActiveStateSignatures, creditBalanceSignatures = _d.creditBalanceSignatures, debitActiveStateSignatures = _d.debitActiveStateSignatures, debitBalanceSignatures = _d.debitBalanceSignatures, fulfillmentActiveStateSignatures = _d.fulfillmentActiveStateSignatures;\n          return [4, operator_1.operator.sendSwapOrder({\n            amount: debitAmount,\n            amountSwapped: creditAmount,\n            creditActiveStateSignatures: creditActiveStateSignatures,\n            debitActiveStateSignatures: debitActiveStateSignatures,\n            creditBalanceSignatures: creditBalanceSignatures,\n            debitBalanceSignatures: debitBalanceSignatures,\n            fulfillmentActiveStateSignatures: fulfillmentActiveStateSignatures,\n            creditWallet: creditWallet,\n            debitWallet: debitWallet,\n            eon: debitWallet.currentEon.eon,\n            nonce: nonce\n          })];\n        case 11:\n          swapPayload_1 = _f.sent();\n          return [4, syncWallet_1.syncWallet(creditWallet, syncWallet_1.SyncWalletEvent.SYNC_TRANSACTIONS, {\n            payloads: [swapPayload_1]\n          })];\n        case 12:\n          _f.sent();\n          return [4, syncWallet_1.syncWallet(debitWallet, syncWallet_1.SyncWalletEvent.SYNC_TRANSACTIONS, {\n            payloads: [swapPayload_1]\n          })];\n        case 13:\n          _f.sent();\n          return [2, creditWallet.currentEon.transactions.find(function (t) {\n            return t.id === swapPayload_1.id;\n          })];\n        case 14:\n          e_1 = _f.sent();\n          if (!(e_1.message === errors_1.NCServerErrorCode.EON_NUMBER_OUT_OF_SYNC)) return [3, 19];\n          return [4, utils_1.sleep(2000)];\n        case 15:\n          _f.sent();\n          return [4, getAvailableSwapWallets(config.address, creditToken, debitToken)];\n        case 16:\n          _e = _f.sent(), creditWallet = _e.creditWallet, debitWallet = _e.debitWallet;\n          return [4, syncWallet_1.syncWallet(creditWallet, syncWallet_1.SyncWalletEvent.FULL_SYNC)];\n        case 17:\n          _f.sent();\n          return [4, syncWallet_1.syncWallet(debitWallet, syncWallet_1.SyncWalletEvent.FULL_SYNC)];\n        case 18:\n          _f.sent();\n          return [2, addOrder(config)];\n        case 19:\n          return [2, Promise.reject(e_1)];\n        case 20:\n          return [3, 21];\n        case 21:\n          return [2];\n      }\n    });\n  });\n}\nexports.default = addOrder;\nfunction getAvailableSwapWallets(address, creditToken, debitToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    var swapWalletAddresses, i, creditWallet, debitWallet, e_2;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 6,, 7]);\n          swapWalletAddresses = store_1.store.swapWallets.get(address);\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!(i < swapWalletAddresses.length)) return [3, 5];\n          return [4, getWallet_1.default(swapWalletAddresses[i], creditToken, address)];\n        case 2:\n          creditWallet = _a.sent();\n          return [4, getWallet_1.default(swapWalletAddresses[i], debitToken, address)];\n        case 3:\n          debitWallet = _a.sent();\n          if (creditWallet.currentEon.isAvailableForSwaps && debitWallet.currentEon.isAvailableForSwaps) {\n            return [2, {\n              creditWallet: creditWallet,\n              debitWallet: debitWallet\n            }];\n          }\n          _a.label = 4;\n        case 4:\n          i++;\n          return [3, 1];\n        case 5:\n          return [2, Promise.reject(new errors_1.NCError(errors_1.NCErrorCode.SWAP_LIMIT_REACHED_ERROR))];\n        case 6:\n          e_2 = _a.sent();\n          return [2, Promise.reject(e_2)];\n        case 7:\n          return [2];\n      }\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}