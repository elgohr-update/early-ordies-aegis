{"ast":null,"code":"/**\n * Create, import, and export ethereum keys.\n * @author Jack Peterson (jack@tinybike.net)\n */\n\n\"use strict\";\n\nvar isBrowser = typeof process === \"undefined\" || !process.nextTick || Boolean(process.browser);\nvar sjcl = require(\"sjcl\");\nvar uuid = require(\"uuid\");\nvar secp256k1 = require(\"secp256k1/elliptic\");\nvar createKeccakHash = require(\"keccak/js\");\nvar scrypt = require(\"scrypt-js\");\nfunction isFunction(f) {\n  return typeof f === \"function\";\n}\nfunction keccak256(buffer) {\n  return createKeccakHash(\"keccak256\").update(buffer).digest();\n}\nmodule.exports = {\n  version: \"1.1.0\",\n  browser: isBrowser,\n  scrypt: null,\n  crypto: isBrowser ? require(\"crypto-browserify\") : require(\"crypto\"),\n  constants: {\n    // Symmetric cipher for private key encryption\n    cipher: \"aes-128-ctr\",\n    // Initialization vector size in bytes\n    ivBytes: 16,\n    // ECDSA private key size in bytes\n    keyBytes: 32,\n    // Key derivation function parameters\n    pbkdf2: {\n      c: 262144,\n      dklen: 32,\n      hash: \"sha256\",\n      prf: \"hmac-sha256\"\n    },\n    scrypt: {\n      memory: 280000000,\n      dklen: 32,\n      n: 262144,\n      r: 8,\n      p: 1\n    }\n  },\n  /**\n   * Check whether a string is valid hex.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid hex, false otherwise.\n   */\n  isHex: function isHex(str) {\n    if (str.length % 2 === 0 && str.match(/^[0-9a-f]+$/i)) return true;\n    return false;\n  },\n  /**\n   * Check whether a string is valid base-64.\n   * @param {string} str String to validate.\n   * @return {boolean} True if the string is valid base-64, false otherwise.\n   */\n  isBase64: function isBase64(str) {\n    var index;\n    if (str.length % 4 > 0 || str.match(/[^0-9a-z+\\/=]/i)) return false;\n    index = str.indexOf(\"=\");\n    if (index === -1 || str.slice(index).match(/={1,2}/)) return true;\n    return false;\n  },\n  /**\n   * Convert a string to a Buffer.  If encoding is not specified, hex-encoding\n   * will be used if the input is valid hex.  If the input is valid base64 but\n   * not valid hex, base64 will be used.  Otherwise, utf8 will be used.\n   * @param {string} str String to be converted.\n   * @param {string=} enc Encoding of the input string (optional).\n   * @return {Buffer} Buffer (bytearray) containing the input data.\n   */\n  str2buf: function str2buf(str, enc) {\n    if (!str || str.constructor !== String) return str;\n    if (!enc && this.isHex(str)) enc = \"hex\";\n    if (!enc && this.isBase64(str)) enc = \"base64\";\n    return Buffer.from(str, enc);\n  },\n  /**\n   * Check if the selected cipher is available.\n   * @param {string} cipher Encryption algorithm.\n   * @return {boolean} If available true, otherwise false.\n   */\n  isCipherAvailable: function isCipherAvailable(cipher) {\n    return this.crypto.getCiphers().some(function (name) {\n      return name === cipher;\n    });\n  },\n  /**\n   * Symmetric private key encryption using secret (derived) key.\n   * @param {Buffer|string} plaintext Data to be encrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Encrypted data.\n   */\n  encrypt: function encrypt(plaintext, key, iv, algo) {\n    var cipher, ciphertext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    cipher = this.crypto.createCipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    ciphertext = cipher.update(this.str2buf(plaintext));\n    return Buffer.concat([ciphertext, cipher.final()]);\n  },\n  /**\n   * Symmetric private key decryption using secret (derived) key.\n   * @param {Buffer|string} ciphertext Data to be decrypted.\n   * @param {Buffer|string} key Secret key.\n   * @param {Buffer|string} iv Initialization vector.\n   * @param {string=} algo Encryption algorithm (default: constants.cipher).\n   * @return {Buffer} Decrypted data.\n   */\n  decrypt: function decrypt(ciphertext, key, iv, algo) {\n    var decipher, plaintext;\n    algo = algo || this.constants.cipher;\n    if (!this.isCipherAvailable(algo)) throw new Error(algo + \" is not available\");\n    decipher = this.crypto.createDecipheriv(algo, this.str2buf(key), this.str2buf(iv));\n    plaintext = decipher.update(this.str2buf(ciphertext));\n    return Buffer.concat([plaintext, decipher.final()]);\n  },\n  /**\n   * Derive Ethereum address from private key.\n   * @param {Buffer|string} privateKey ECDSA private key.\n   * @return {string} Hex-encoded Ethereum address.\n   */\n  privateKeyToAddress: function privateKeyToAddress(privateKey) {\n    var privateKeyBuffer, publicKey;\n    privateKeyBuffer = this.str2buf(privateKey);\n    if (privateKeyBuffer.length < 32) {\n      privateKeyBuffer = Buffer.concat([Buffer.alloc(32 - privateKeyBuffer.length, 0), privateKeyBuffer]);\n    }\n    publicKey = Buffer.from(secp256k1.publicKeyCreate(privateKeyBuffer, false).slice(1));\n    return \"0x\" + keccak256(publicKey).slice(-20).toString(\"hex\");\n  },\n  /**\n   * Calculate message authentication code from secret (derived) key and\n   * encrypted text.  The MAC is the keccak-256 hash of the byte array\n   * formed by concatenating the second 16 bytes of the derived key with\n   * the ciphertext key's contents.\n   * @param {Buffer|string} derivedKey Secret key derived from password.\n   * @param {Buffer|string} ciphertext Text encrypted with secret key.\n   * @return {string} Hex-encoded MAC.\n   */\n  getMAC: function getMAC(derivedKey, ciphertext) {\n    if (derivedKey !== undefined && derivedKey !== null && ciphertext !== undefined && ciphertext !== null) {\n      return keccak256(Buffer.concat([this.str2buf(derivedKey).slice(16, 32), this.str2buf(ciphertext)])).toString(\"hex\");\n    }\n  },\n  /**\n   * Used internally.\n   */\n  deriveKeyUsingScrypt: function deriveKeyUsingScrypt(password, salt, options, cb) {\n    var n = options.kdfparams.n || this.constants.scrypt.n;\n    var r = options.kdfparams.r || this.constants.scrypt.r;\n    var p = options.kdfparams.p || this.constants.scrypt.p;\n    var dklen = options.kdfparams.dklen || this.constants.scrypt.dklen;\n    if (isFunction(cb)) {\n      scrypt.scrypt(password, salt, n, r, p, dklen).then(function (key) {\n        cb(Buffer.from(key));\n      }).catch(cb);\n    } else {\n      return Buffer.from(scrypt.syncScrypt(password, salt, n, r, p, dklen));\n    }\n  },\n  /**\n   * Derive secret key from password with key dervation function.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Secret key derived from password.\n   */\n  deriveKey: function deriveKey(password, salt, options, cb) {\n    var prf,\n      self = this;\n    if (typeof password === \"undefined\" || password === null || !salt) {\n      throw new Error(\"Must provide password and salt to derive a key\");\n    }\n    options = options || {};\n    options.kdfparams = options.kdfparams || {};\n\n    // convert strings to buffers\n    password = this.str2buf(password, \"utf8\");\n    salt = this.str2buf(salt);\n\n    // use scrypt as key derivation function\n    if (options.kdf === \"scrypt\") {\n      return this.deriveKeyUsingScrypt(password, salt, options, cb);\n    }\n\n    // use default key derivation function (PBKDF2)\n    prf = options.kdfparams.prf || this.constants.pbkdf2.prf;\n    if (prf === \"hmac-sha256\") prf = \"sha256\";\n    if (!isFunction(cb)) {\n      if (!this.crypto.pbkdf2Sync) {\n        return Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(password.toString(\"utf8\"), sjcl.codec.hex.toBits(salt.toString(\"hex\")), options.kdfparams.c || self.constants.pbkdf2.c, (options.kdfparams.dklen || self.constants.pbkdf2.dklen) * 8)), \"hex\");\n      }\n      return this.crypto.pbkdf2Sync(password, salt, options.kdfparams.c || this.constants.pbkdf2.c, options.kdfparams.dklen || this.constants.pbkdf2.dklen, prf);\n    }\n    if (!this.crypto.pbkdf2) {\n      setTimeout(function () {\n        cb(Buffer.from(sjcl.codec.hex.fromBits(sjcl.misc.pbkdf2(password.toString(\"utf8\"), sjcl.codec.hex.toBits(salt.toString(\"hex\")), options.kdfparams.c || self.constants.pbkdf2.c, (options.kdfparams.dklen || self.constants.pbkdf2.dklen) * 8)), \"hex\"));\n      }, 0);\n    } else {\n      this.crypto.pbkdf2(password, salt, options.kdfparams.c || this.constants.pbkdf2.c, options.kdfparams.dklen || this.constants.pbkdf2.dklen, prf, function (ex, derivedKey) {\n        if (ex) return cb(ex);\n        cb(derivedKey);\n      });\n    }\n  },\n  /**\n   * Generate random numbers for private key, initialization vector,\n   * and salt (for key derivation).\n   * @param {Object=} params Encryption options (defaults: constants).\n   * @param {string=} params.keyBytes Private key size in bytes.\n   * @param {string=} params.ivBytes Initialization vector size in bytes.\n   * @param {function=} cb Callback function (optional).\n   * @return {Object<string,Buffer>} Private key, IV and salt.\n   */\n  create: function create(params, cb) {\n    var keyBytes,\n      ivBytes,\n      self = this;\n    params = params || {};\n    keyBytes = params.keyBytes || this.constants.keyBytes;\n    ivBytes = params.ivBytes || this.constants.ivBytes;\n    function checkBoundsAndCreateObject(randomBytes) {\n      var privateKey = randomBytes.slice(0, keyBytes);\n      if (!secp256k1.privateKeyVerify(privateKey)) return self.create(params, cb);\n      return {\n        privateKey: privateKey,\n        iv: randomBytes.slice(keyBytes, keyBytes + ivBytes),\n        salt: randomBytes.slice(keyBytes + ivBytes)\n      };\n    }\n\n    // synchronous key generation if callback not provided\n    if (!isFunction(cb)) {\n      return checkBoundsAndCreateObject(this.crypto.randomBytes(keyBytes + ivBytes + keyBytes));\n    }\n\n    // asynchronous key generation\n    this.crypto.randomBytes(keyBytes + ivBytes + keyBytes, function (err, randomBytes) {\n      if (err) return cb(err);\n      cb(checkBoundsAndCreateObject(randomBytes));\n    });\n  },\n  /**\n   * Assemble key data object in secret-storage format.\n   * @param {Buffer} derivedKey Password-derived secret key.\n   * @param {Buffer} privateKey Private key.\n   * @param {Buffer} salt Randomly generated salt.\n   * @param {Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @return {Object}\n   */\n  marshal: function marshal(derivedKey, privateKey, salt, iv, options) {\n    var ciphertext, keyObject, algo;\n    options = options || {};\n    options.kdfparams = options.kdfparams || {};\n    algo = options.cipher || this.constants.cipher;\n\n    // encrypt using first 16 bytes of derived key\n    ciphertext = this.encrypt(privateKey, derivedKey.slice(0, 16), iv, algo).toString(\"hex\");\n    keyObject = {\n      address: this.privateKeyToAddress(privateKey).slice(2),\n      crypto: {\n        cipher: options.cipher || this.constants.cipher,\n        ciphertext: ciphertext,\n        cipherparams: {\n          iv: iv.toString(\"hex\")\n        },\n        mac: this.getMAC(derivedKey, ciphertext)\n      },\n      id: uuid.v4(),\n      // random 128-bit UUID\n      version: 3\n    };\n    if (options.kdf === \"scrypt\") {\n      keyObject.crypto.kdf = \"scrypt\";\n      keyObject.crypto.kdfparams = {\n        dklen: options.kdfparams.dklen || this.constants.scrypt.dklen,\n        n: options.kdfparams.n || this.constants.scrypt.n,\n        r: options.kdfparams.r || this.constants.scrypt.r,\n        p: options.kdfparams.p || this.constants.scrypt.p,\n        salt: salt.toString(\"hex\")\n      };\n    } else {\n      keyObject.crypto.kdf = \"pbkdf2\";\n      keyObject.crypto.kdfparams = {\n        c: options.kdfparams.c || this.constants.pbkdf2.c,\n        dklen: options.kdfparams.dklen || this.constants.pbkdf2.dklen,\n        prf: options.kdfparams.prf || this.constants.pbkdf2.prf,\n        salt: salt.toString(\"hex\")\n      };\n    }\n    return keyObject;\n  },\n  /**\n   * Export private key to keystore secret-storage format.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {string|Buffer} privateKey Private key.\n   * @param {string|Buffer} salt Randomly generated salt.\n   * @param {string|Buffer} iv Initialization vector.\n   * @param {Object=} options Encryption parameters.\n   * @param {string=} options.kdf Key derivation function (default: pbkdf2).\n   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).\n   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object}\n   */\n  dump: function dump(password, privateKey, salt, iv, options, cb) {\n    options = options || {};\n    iv = this.str2buf(iv);\n    privateKey = this.str2buf(privateKey);\n\n    // synchronous if no callback provided\n    if (!isFunction(cb)) {\n      return this.marshal(this.deriveKey(password, salt, options), privateKey, salt, iv, options);\n    }\n\n    // asynchronous if callback provided\n    this.deriveKey(password, salt, options, function (derivedKey) {\n      cb(this.marshal(derivedKey, privateKey, salt, iv, options));\n    }.bind(this));\n  },\n  /**\n   * Recover plaintext private key from secret-storage key object.\n   * @param {string|Buffer} password User-supplied password.\n   * @param {Object} keyObject Keystore object.\n   * @param {function=} cb Callback function (optional).\n   * @return {Buffer} Plaintext private key.\n   */\n  recover: function recover(password, keyObject, cb) {\n    var keyObjectCrypto,\n      iv,\n      salt,\n      ciphertext,\n      algo,\n      self = this;\n    keyObjectCrypto = keyObject.Crypto || keyObject.crypto;\n\n    // verify that message authentication codes match, then decrypt\n    function verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo) {\n      var key;\n      if (self.getMAC(derivedKey, ciphertext) !== keyObjectCrypto.mac) {\n        throw new Error(\"message authentication code mismatch\");\n      }\n      if (keyObject.version === \"1\") {\n        key = keccak256(derivedKey.slice(0, 16)).slice(0, 16);\n      } else {\n        key = derivedKey.slice(0, 16);\n      }\n      return self.decrypt(ciphertext, key, iv, algo);\n    }\n    iv = this.str2buf(keyObjectCrypto.cipherparams.iv);\n    salt = this.str2buf(keyObjectCrypto.kdfparams.salt);\n    ciphertext = this.str2buf(keyObjectCrypto.ciphertext);\n    algo = keyObjectCrypto.cipher;\n    if (keyObjectCrypto.kdf === \"pbkdf2\" && keyObjectCrypto.kdfparams.prf !== \"hmac-sha256\") {\n      throw new Error(\"PBKDF2 only supported with HMAC-SHA256\");\n    }\n\n    // derive secret key from password\n    if (!isFunction(cb)) {\n      return verifyAndDecrypt(this.deriveKey(password, salt, keyObjectCrypto), salt, iv, ciphertext, algo);\n    }\n    this.deriveKey(password, salt, keyObjectCrypto, function (derivedKey) {\n      try {\n        cb(verifyAndDecrypt(derivedKey, salt, iv, ciphertext, algo));\n      } catch (exc) {\n        cb(exc);\n      }\n    });\n  },\n  /**\n   * Generate filename for a keystore file.\n   * @param {string} address Ethereum address.\n   * @return {string} Keystore filename.\n   */\n  generateKeystoreFilename: function generateKeystoreFilename(address) {\n    var filename = \"UTC--\" + new Date().toISOString() + \"--\" + address;\n\n    // Windows does not permit \":\" in filenames, replace all with \"-\"\n    if (process.platform === \"win32\") filename = filename.split(\":\").join(\"-\");\n    return filename;\n  },\n  /**\n   * Export formatted JSON to keystore file.\n   * @param {Object} keyObject Keystore object.\n   * @param {string=} keystore Path to keystore folder (default: \"keystore\").\n   * @param {function=} cb Callback function (optional).\n   * @return {string} JSON filename (Node.js) or JSON string (browser).\n   */\n  exportToFile: function exportToFile(keyObject, keystore, cb) {\n    var outfile, outpath, json, fs;\n    keystore = keystore || \"keystore\";\n    outfile = this.generateKeystoreFilename(keyObject.address);\n    json = JSON.stringify(keyObject);\n    if (this.browser) {\n      if (!isFunction(cb)) return json;\n      return cb(json);\n    }\n    outpath = require(\"path\").join(keystore, outfile);\n    fs = require(\"fs\");\n    if (!isFunction(cb)) {\n      fs.writeFileSync(outpath, json);\n      return outpath;\n    }\n    fs.writeFile(outpath, json, function (err) {\n      if (err) return cb(err);\n      cb(outpath);\n    });\n  },\n  /**\n   * Import key data object from keystore JSON file.\n   * (Note: Node.js only!)\n   * @param {string} address Ethereum address to import.\n   * @param {string=} datadir Ethereum data directory (default: ~/.ethereum).\n   * @param {function=} cb Callback function (optional).\n   * @return {Object} Keystore data file's contents.\n   */\n  importFromFile: function importFromFile(address, datadir, cb) {\n    var keystore, filepath, path, fs;\n    if (this.browser) throw new Error(\"method only available in Node.js\");\n    path = require(\"path\");\n    fs = require(\"fs\");\n    address = address.replace(\"0x\", \"\");\n    address = address.toLowerCase();\n    function findKeyfile(keystore, address, files) {\n      var i,\n        len,\n        filepath = null;\n      for (i = 0, len = files.length; i < len; ++i) {\n        if (files[i].indexOf(address) > -1) {\n          filepath = path.join(keystore, files[i]);\n          if (fs.lstatSync(filepath).isDirectory()) {\n            filepath = path.join(filepath, files[i]);\n          }\n          break;\n        }\n      }\n      return filepath;\n    }\n    datadir = datadir || path.join(process.env.HOME, \".ethereum\");\n    keystore = path.join(datadir, \"keystore\");\n    if (!isFunction(cb)) {\n      filepath = findKeyfile(keystore, address, fs.readdirSync(keystore));\n      if (!filepath) {\n        throw new Error(\"could not find key file for address \" + address);\n      }\n      return JSON.parse(fs.readFileSync(filepath));\n    }\n    fs.readdir(keystore, function (ex, files) {\n      var filepath;\n      if (ex) return cb(ex);\n      filepath = findKeyfile(keystore, address, files);\n      if (!filepath) {\n        return cb(new Error(\"could not find key file for address \" + address));\n      }\n      return cb(JSON.parse(fs.readFileSync(filepath)));\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}