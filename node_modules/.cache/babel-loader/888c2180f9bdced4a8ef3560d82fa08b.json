{"ast":null,"code":"\"use strict\";\n\nvar sjcl = {\n  cipher: {},\n  hash: {},\n  keyexchange: {},\n  mode: {},\n  misc: {},\n  codec: {},\n  exception: {\n    corrupt: function corrupt(a) {\n      this.toString = function () {\n        return \"CORRUPT: \" + this.message;\n      };\n      this.message = a;\n    },\n    invalid: function invalid(a) {\n      this.toString = function () {\n        return \"INVALID: \" + this.message;\n      };\n      this.message = a;\n    },\n    bug: function bug(a) {\n      this.toString = function () {\n        return \"BUG: \" + this.message;\n      };\n      this.message = a;\n    },\n    notReady: function notReady(a) {\n      this.toString = function () {\n        return \"NOT READY: \" + this.message;\n      };\n      this.message = a;\n    }\n  }\n};\nsjcl.cipher.aes = function (a) {\n  this.s[0][0][0] || this.O();\n  var b,\n    c,\n    d,\n    e,\n    f = this.s[0][4],\n    g = this.s[1];\n  b = a.length;\n  var h = 1;\n  if (4 !== b && 6 !== b && 8 !== b) throw new sjcl.exception.invalid(\"invalid aes key size\");\n  this.b = [d = a.slice(0), e = []];\n  for (a = b; a < 4 * b + 28; a++) {\n    c = d[a - 1];\n    if (0 === a % b || 8 === b && 4 === a % b) c = f[c >>> 24] << 24 ^ f[c >> 16 & 255] << 16 ^ f[c >> 8 & 255] << 8 ^ f[c & 255], 0 === a % b && (c = c << 8 ^ c >>> 24 ^ h << 24, h = h << 1 ^ 283 * (h >> 7));\n    d[a] = d[a - b] ^ c;\n  }\n  for (b = 0; a; b++, a--) {\n    c = d[b & 3 ? a : a - 4], e[b] = 4 >= a || 4 > b ? c : g[0][f[c >>> 24]] ^ g[1][f[c >> 16 & 255]] ^ g[2][f[c >> 8 & 255]] ^ g[3][f[c & 255]];\n  }\n};\nsjcl.cipher.aes.prototype = {\n  encrypt: function encrypt(a) {\n    return t(this, a, 0);\n  },\n  decrypt: function decrypt(a) {\n    return t(this, a, 1);\n  },\n  s: [[[], [], [], [], []], [[], [], [], [], []]],\n  O: function O() {\n    var a = this.s[0],\n      b = this.s[1],\n      c = a[4],\n      d = b[4],\n      e,\n      f,\n      g,\n      h = [],\n      k = [],\n      l,\n      n,\n      m,\n      p;\n    for (e = 0; 0x100 > e; e++) {\n      k[(h[e] = e << 1 ^ 283 * (e >> 7)) ^ e] = e;\n    }\n    for (f = g = 0; !c[f]; f ^= l || 1, g = k[g] || 1) {\n      for (m = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4, m = m >> 8 ^ m & 255 ^ 99, c[f] = m, d[m] = f, n = h[e = h[l = h[f]]], p = 0x1010101 * n ^ 0x10001 * e ^ 0x101 * l ^ 0x1010100 * f, n = 0x101 * h[m] ^ 0x1010100 * m, e = 0; 4 > e; e++) {\n        a[e][f] = n = n << 24 ^ n >>> 8, b[e][m] = p = p << 24 ^ p >>> 8;\n      }\n    }\n    for (e = 0; 5 > e; e++) {\n      a[e] = a[e].slice(0), b[e] = b[e].slice(0);\n    }\n  }\n};\nfunction t(a, b, c) {\n  if (4 !== b.length) throw new sjcl.exception.invalid(\"invalid aes block size\");\n  var d = a.b[c],\n    e = b[0] ^ d[0],\n    f = b[c ? 3 : 1] ^ d[1],\n    g = b[2] ^ d[2];\n  b = b[c ? 1 : 3] ^ d[3];\n  var h,\n    k,\n    l,\n    n = d.length / 4 - 2,\n    m,\n    p = 4,\n    r = [0, 0, 0, 0];\n  h = a.s[c];\n  a = h[0];\n  var q = h[1],\n    v = h[2],\n    w = h[3],\n    x = h[4];\n  for (m = 0; m < n; m++) {\n    h = a[e >>> 24] ^ q[f >> 16 & 255] ^ v[g >> 8 & 255] ^ w[b & 255] ^ d[p], k = a[f >>> 24] ^ q[g >> 16 & 255] ^ v[b >> 8 & 255] ^ w[e & 255] ^ d[p + 1], l = a[g >>> 24] ^ q[b >> 16 & 255] ^ v[e >> 8 & 255] ^ w[f & 255] ^ d[p + 2], b = a[b >>> 24] ^ q[e >> 16 & 255] ^ v[f >> 8 & 255] ^ w[g & 255] ^ d[p + 3], p += 4, e = h, f = k, g = l;\n  }\n  for (m = 0; 4 > m; m++) {\n    r[c ? 3 & -m : m] = x[e >>> 24] << 24 ^ x[f >> 16 & 255] << 16 ^ x[g >> 8 & 255] << 8 ^ x[b & 255] ^ d[p++], h = e, e = f, f = g, g = b, b = h;\n  }\n  return r;\n}\nsjcl.bitArray = {\n  bitSlice: function bitSlice(a, b, c) {\n    a = sjcl.bitArray.$(a.slice(b / 32), 32 - (b & 31)).slice(1);\n    return void 0 === c ? a : sjcl.bitArray.clamp(a, c - b);\n  },\n  extract: function extract(a, b, c) {\n    var d = Math.floor(-b - c & 31);\n    return ((b + c - 1 ^ b) & -32 ? a[b / 32 | 0] << 32 - d ^ a[b / 32 + 1 | 0] >>> d : a[b / 32 | 0] >>> d) & (1 << c) - 1;\n  },\n  concat: function concat(a, b) {\n    if (0 === a.length || 0 === b.length) return a.concat(b);\n    var c = a[a.length - 1],\n      d = sjcl.bitArray.getPartial(c);\n    return 32 === d ? a.concat(b) : sjcl.bitArray.$(b, d, c | 0, a.slice(0, a.length - 1));\n  },\n  bitLength: function bitLength(a) {\n    var b = a.length;\n    return 0 === b ? 0 : 32 * (b - 1) + sjcl.bitArray.getPartial(a[b - 1]);\n  },\n  clamp: function clamp(a, b) {\n    if (32 * a.length < b) return a;\n    a = a.slice(0, Math.ceil(b / 32));\n    var c = a.length;\n    b = b & 31;\n    0 < c && b && (a[c - 1] = sjcl.bitArray.partial(b, a[c - 1] & 2147483648 >> b - 1, 1));\n    return a;\n  },\n  partial: function partial(a, b, c) {\n    return 32 === a ? b : (c ? b | 0 : b << 32 - a) + 0x10000000000 * a;\n  },\n  getPartial: function getPartial(a) {\n    return Math.round(a / 0x10000000000) || 32;\n  },\n  equal: function equal(a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) return !1;\n    var c = 0,\n      d;\n    for (d = 0; d < a.length; d++) {\n      c |= a[d] ^ b[d];\n    }\n    return 0 === c;\n  },\n  $: function $(a, b, c, d) {\n    var e;\n    e = 0;\n    for (void 0 === d && (d = []); 32 <= b; b -= 32) {\n      d.push(c), c = 0;\n    }\n    if (0 === b) return d.concat(a);\n    for (e = 0; e < a.length; e++) {\n      d.push(c | a[e] >>> b), c = a[e] << 32 - b;\n    }\n    e = a.length ? a[a.length - 1] : 0;\n    a = sjcl.bitArray.getPartial(e);\n    d.push(sjcl.bitArray.partial(b + a & 31, 32 < b + a ? c : d.pop(), 1));\n    return d;\n  },\n  i: function i(a, b) {\n    return [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]];\n  },\n  byteswapM: function byteswapM(a) {\n    var b, c;\n    for (b = 0; b < a.length; ++b) {\n      c = a[b], a[b] = c >>> 24 | c >>> 8 & 0xff00 | (c & 0xff00) << 8 | c << 24;\n    }\n    return a;\n  }\n};\nsjcl.codec.utf8String = {\n  fromBits: function fromBits(a) {\n    var b = \"\",\n      c = sjcl.bitArray.bitLength(a),\n      d,\n      e;\n    for (d = 0; d < c / 8; d++) {\n      0 === (d & 3) && (e = a[d / 4]), b += String.fromCharCode(e >>> 24), e <<= 8;\n    }\n    return decodeURIComponent(escape(b));\n  },\n  toBits: function toBits(a) {\n    a = unescape(encodeURIComponent(a));\n    var b = [],\n      c,\n      d = 0;\n    for (c = 0; c < a.length; c++) {\n      d = d << 8 | a.charCodeAt(c), 3 === (c & 3) && (b.push(d), d = 0);\n    }\n    c & 3 && b.push(sjcl.bitArray.partial(8 * (c & 3), d));\n    return b;\n  }\n};\nsjcl.codec.hex = {\n  fromBits: function fromBits(a) {\n    var b = \"\",\n      c;\n    for (c = 0; c < a.length; c++) {\n      b += ((a[c] | 0) + 0xf00000000000).toString(16).substr(4);\n    }\n    return b.substr(0, sjcl.bitArray.bitLength(a) / 4);\n  },\n  toBits: function toBits(a) {\n    var b,\n      c = [],\n      d;\n    a = a.replace(/\\s|0x/g, \"\");\n    d = a.length;\n    a = a + \"00000000\";\n    for (b = 0; b < a.length; b += 8) {\n      c.push(parseInt(a.substr(b, 8), 16) ^ 0);\n    }\n    return sjcl.bitArray.clamp(c, 4 * d);\n  }\n};\nsjcl.codec.base32 = {\n  B: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  X: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  BITS: 32,\n  BASE: 5,\n  REMAINING: 27,\n  fromBits: function fromBits(a, b, c) {\n    var d = sjcl.codec.base32.BASE,\n      e = sjcl.codec.base32.REMAINING,\n      f = \"\",\n      g = 0,\n      h = sjcl.codec.base32.B,\n      k = 0,\n      l = sjcl.bitArray.bitLength(a);\n    c && (h = sjcl.codec.base32.X);\n    for (c = 0; f.length * d < l;) {\n      f += h.charAt((k ^ a[c] >>> g) >>> e), g < d ? (k = a[c] << d - g, g += e, c++) : (k <<= d, g -= d);\n    }\n    for (; f.length & 7 && !b;) {\n      f += \"=\";\n    }\n    return f;\n  },\n  toBits: function toBits(a, b) {\n    a = a.replace(/\\s|=/g, \"\").toUpperCase();\n    var c = sjcl.codec.base32.BITS,\n      d = sjcl.codec.base32.BASE,\n      e = sjcl.codec.base32.REMAINING,\n      f = [],\n      g,\n      h = 0,\n      k = sjcl.codec.base32.B,\n      l = 0,\n      n,\n      m = \"base32\";\n    b && (k = sjcl.codec.base32.X, m = \"base32hex\");\n    for (g = 0; g < a.length; g++) {\n      n = k.indexOf(a.charAt(g));\n      if (0 > n) {\n        if (!b) try {\n          return sjcl.codec.base32hex.toBits(a);\n        } catch (p) {}\n        throw new sjcl.exception.invalid(\"this isn't \" + m + \"!\");\n      }\n      h > e ? (h -= e, f.push(l ^ n >>> h), l = n << c - h) : (h += d, l ^= n << c - h);\n    }\n    h & 56 && f.push(sjcl.bitArray.partial(h & 56, l, 1));\n    return f;\n  }\n};\nsjcl.codec.base32hex = {\n  fromBits: function fromBits(a, b) {\n    return sjcl.codec.base32.fromBits(a, b, 1);\n  },\n  toBits: function toBits(a) {\n    return sjcl.codec.base32.toBits(a, 1);\n  }\n};\nsjcl.codec.base64 = {\n  B: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  fromBits: function fromBits(a, b, c) {\n    var d = \"\",\n      e = 0,\n      f = sjcl.codec.base64.B,\n      g = 0,\n      h = sjcl.bitArray.bitLength(a);\n    c && (f = f.substr(0, 62) + \"-_\");\n    for (c = 0; 6 * d.length < h;) {\n      d += f.charAt((g ^ a[c] >>> e) >>> 26), 6 > e ? (g = a[c] << 6 - e, e += 26, c++) : (g <<= 6, e -= 6);\n    }\n    for (; d.length & 3 && !b;) {\n      d += \"=\";\n    }\n    return d;\n  },\n  toBits: function toBits(a, b) {\n    a = a.replace(/\\s|=/g, \"\");\n    var c = [],\n      d,\n      e = 0,\n      f = sjcl.codec.base64.B,\n      g = 0,\n      h;\n    b && (f = f.substr(0, 62) + \"-_\");\n    for (d = 0; d < a.length; d++) {\n      h = f.indexOf(a.charAt(d));\n      if (0 > h) throw new sjcl.exception.invalid(\"this isn't base64!\");\n      26 < e ? (e -= 26, c.push(g ^ h >>> e), g = h << 32 - e) : (e += 6, g ^= h << 32 - e);\n    }\n    e & 56 && c.push(sjcl.bitArray.partial(e & 56, g, 1));\n    return c;\n  }\n};\nsjcl.codec.base64url = {\n  fromBits: function fromBits(a) {\n    return sjcl.codec.base64.fromBits(a, 1, 1);\n  },\n  toBits: function toBits(a) {\n    return sjcl.codec.base64.toBits(a, 1);\n  }\n};\nsjcl.hash.sha256 = function (a) {\n  this.b[0] || this.O();\n  a ? (this.F = a.F.slice(0), this.A = a.A.slice(0), this.l = a.l) : this.reset();\n};\nsjcl.hash.sha256.hash = function (a) {\n  return new sjcl.hash.sha256().update(a).finalize();\n};\nsjcl.hash.sha256.prototype = {\n  blockSize: 512,\n  reset: function reset() {\n    this.F = this.Y.slice(0);\n    this.A = [];\n    this.l = 0;\n    return this;\n  },\n  update: function update(a) {\n    \"string\" === typeof a && (a = sjcl.codec.utf8String.toBits(a));\n    var b,\n      c = this.A = sjcl.bitArray.concat(this.A, a);\n    b = this.l;\n    a = this.l = b + sjcl.bitArray.bitLength(a);\n    if (0x1fffffffffffff < a) throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    if (\"undefined\" !== typeof Uint32Array) {\n      var d = new Uint32Array(c),\n        e = 0;\n      for (b = 512 + b - (512 + b & 0x1ff); b <= a; b += 512) {\n        u(this, d.subarray(16 * e, 16 * (e + 1))), e += 1;\n      }\n      c.splice(0, 16 * e);\n    } else for (b = 512 + b - (512 + b & 0x1ff); b <= a; b += 512) {\n      u(this, c.splice(0, 16));\n    }\n    return this;\n  },\n  finalize: function finalize() {\n    var a,\n      b = this.A,\n      c = this.F,\n      b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);\n    for (a = b.length + 2; a & 15; a++) {\n      b.push(0);\n    }\n    b.push(Math.floor(this.l / 0x100000000));\n    for (b.push(this.l | 0); b.length;) {\n      u(this, b.splice(0, 16));\n    }\n    this.reset();\n    return c;\n  },\n  Y: [],\n  b: [],\n  O: function O() {\n    function a(a) {\n      return 0x100000000 * (a - Math.floor(a)) | 0;\n    }\n    for (var b = 0, c = 2, d, e; 64 > b; c++) {\n      e = !0;\n      for (d = 2; d * d <= c; d++) {\n        if (0 === c % d) {\n          e = !1;\n          break;\n        }\n      }\n      e && (8 > b && (this.Y[b] = a(Math.pow(c, .5))), this.b[b] = a(Math.pow(c, 1 / 3)), b++);\n    }\n  }\n};\nfunction u(a, b) {\n  var c,\n    d,\n    e,\n    f = a.F,\n    g = a.b,\n    h = f[0],\n    k = f[1],\n    l = f[2],\n    n = f[3],\n    m = f[4],\n    p = f[5],\n    r = f[6],\n    q = f[7];\n  for (c = 0; 64 > c; c++) {\n    16 > c ? d = b[c] : (d = b[c + 1 & 15], e = b[c + 14 & 15], d = b[c & 15] = (d >>> 7 ^ d >>> 18 ^ d >>> 3 ^ d << 25 ^ d << 14) + (e >>> 17 ^ e >>> 19 ^ e >>> 10 ^ e << 15 ^ e << 13) + b[c & 15] + b[c + 9 & 15] | 0), d = d + q + (m >>> 6 ^ m >>> 11 ^ m >>> 25 ^ m << 26 ^ m << 21 ^ m << 7) + (r ^ m & (p ^ r)) + g[c], q = r, r = p, p = m, m = n + d | 0, n = l, l = k, k = h, h = d + (k & l ^ n & (k ^ l)) + (k >>> 2 ^ k >>> 13 ^ k >>> 22 ^ k << 30 ^ k << 19 ^ k << 10) | 0;\n  }\n  f[0] = f[0] + h | 0;\n  f[1] = f[1] + k | 0;\n  f[2] = f[2] + l | 0;\n  f[3] = f[3] + n | 0;\n  f[4] = f[4] + m | 0;\n  f[5] = f[5] + p | 0;\n  f[6] = f[6] + r | 0;\n  f[7] = f[7] + q | 0;\n}\nsjcl.mode.ccm = {\n  name: \"ccm\",\n  G: [],\n  listenProgress: function listenProgress(a) {\n    sjcl.mode.ccm.G.push(a);\n  },\n  unListenProgress: function unListenProgress(a) {\n    a = sjcl.mode.ccm.G.indexOf(a);\n    -1 < a && sjcl.mode.ccm.G.splice(a, 1);\n  },\n  fa: function fa(a) {\n    var b = sjcl.mode.ccm.G.slice(),\n      c;\n    for (c = 0; c < b.length; c += 1) {\n      b[c](a);\n    }\n  },\n  encrypt: function encrypt(a, b, c, d, e) {\n    var f,\n      g = b.slice(0),\n      h = sjcl.bitArray,\n      k = h.bitLength(c) / 8,\n      l = h.bitLength(g) / 8;\n    e = e || 64;\n    d = d || [];\n    if (7 > k) throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    for (f = 2; 4 > f && l >>> 8 * f; f++) {\n      ;\n    }\n    f < 15 - k && (f = 15 - k);\n    c = h.clamp(c, 8 * (15 - f));\n    b = sjcl.mode.ccm.V(a, b, c, d, e, f);\n    g = sjcl.mode.ccm.C(a, g, c, b, e, f);\n    return h.concat(g.data, g.tag);\n  },\n  decrypt: function decrypt(a, b, c, d, e) {\n    e = e || 64;\n    d = d || [];\n    var f = sjcl.bitArray,\n      g = f.bitLength(c) / 8,\n      h = f.bitLength(b),\n      k = f.clamp(b, h - e),\n      l = f.bitSlice(b, h - e),\n      h = (h - e) / 8;\n    if (7 > g) throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    for (b = 2; 4 > b && h >>> 8 * b; b++) {\n      ;\n    }\n    b < 15 - g && (b = 15 - g);\n    c = f.clamp(c, 8 * (15 - b));\n    k = sjcl.mode.ccm.C(a, k, c, l, e, b);\n    a = sjcl.mode.ccm.V(a, k.data, c, d, e, b);\n    if (!f.equal(k.tag, a)) throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    return k.data;\n  },\n  na: function na(a, b, c, d, e, f) {\n    var g = [],\n      h = sjcl.bitArray,\n      k = h.i;\n    d = [h.partial(8, (b.length ? 64 : 0) | d - 2 << 2 | f - 1)];\n    d = h.concat(d, c);\n    d[3] |= e;\n    d = a.encrypt(d);\n    if (b.length) for (c = h.bitLength(b) / 8, 65279 >= c ? g = [h.partial(16, c)] : 0xffffffff >= c && (g = h.concat([h.partial(16, 65534)], [c])), g = h.concat(g, b), b = 0; b < g.length; b += 4) {\n      d = a.encrypt(k(d, g.slice(b, b + 4).concat([0, 0, 0])));\n    }\n    return d;\n  },\n  V: function V(a, b, c, d, e, f) {\n    var g = sjcl.bitArray,\n      h = g.i;\n    e /= 8;\n    if (e % 2 || 4 > e || 16 < e) throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    if (0xffffffff < d.length || 0xffffffff < b.length) throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    c = sjcl.mode.ccm.na(a, d, c, e, g.bitLength(b) / 8, f);\n    for (d = 0; d < b.length; d += 4) {\n      c = a.encrypt(h(c, b.slice(d, d + 4).concat([0, 0, 0])));\n    }\n    return g.clamp(c, 8 * e);\n  },\n  C: function C(a, b, c, d, e, f) {\n    var g,\n      h = sjcl.bitArray;\n    g = h.i;\n    var k = b.length,\n      l = h.bitLength(b),\n      n = k / 50,\n      m = n;\n    c = h.concat([h.partial(8, f - 1)], c).concat([0, 0, 0]).slice(0, 4);\n    d = h.bitSlice(g(d, a.encrypt(c)), 0, e);\n    if (!k) return {\n      tag: d,\n      data: []\n    };\n    for (g = 0; g < k; g += 4) {\n      g > n && (sjcl.mode.ccm.fa(g / k), n += m), c[3]++, e = a.encrypt(c), b[g] ^= e[0], b[g + 1] ^= e[1], b[g + 2] ^= e[2], b[g + 3] ^= e[3];\n    }\n    return {\n      tag: d,\n      data: h.clamp(b, l)\n    };\n  }\n};\nsjcl.mode.ocb2 = {\n  name: \"ocb2\",\n  encrypt: function encrypt(a, b, c, d, e, f) {\n    if (128 !== sjcl.bitArray.bitLength(c)) throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    var g,\n      h = sjcl.mode.ocb2.S,\n      k = sjcl.bitArray,\n      l = k.i,\n      n = [0, 0, 0, 0];\n    c = h(a.encrypt(c));\n    var m,\n      p = [];\n    d = d || [];\n    e = e || 64;\n    for (g = 0; g + 4 < b.length; g += 4) {\n      m = b.slice(g, g + 4), n = l(n, m), p = p.concat(l(c, a.encrypt(l(c, m)))), c = h(c);\n    }\n    m = b.slice(g);\n    b = k.bitLength(m);\n    g = a.encrypt(l(c, [0, 0, 0, b]));\n    m = k.clamp(l(m.concat([0, 0, 0]), g), b);\n    n = l(n, l(m.concat([0, 0, 0]), g));\n    n = a.encrypt(l(n, l(c, h(c))));\n    d.length && (n = l(n, f ? d : sjcl.mode.ocb2.pmac(a, d)));\n    return p.concat(k.concat(m, k.clamp(n, e)));\n  },\n  decrypt: function decrypt(a, b, c, d, e, f) {\n    if (128 !== sjcl.bitArray.bitLength(c)) throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    e = e || 64;\n    var g = sjcl.mode.ocb2.S,\n      h = sjcl.bitArray,\n      k = h.i,\n      l = [0, 0, 0, 0],\n      n = g(a.encrypt(c)),\n      m,\n      p,\n      r = sjcl.bitArray.bitLength(b) - e,\n      q = [];\n    d = d || [];\n    for (c = 0; c + 4 < r / 32; c += 4) {\n      m = k(n, a.decrypt(k(n, b.slice(c, c + 4)))), l = k(l, m), q = q.concat(m), n = g(n);\n    }\n    p = r - 32 * c;\n    m = a.encrypt(k(n, [0, 0, 0, p]));\n    m = k(m, h.clamp(b.slice(c), p).concat([0, 0, 0]));\n    l = k(l, m);\n    l = a.encrypt(k(l, k(n, g(n))));\n    d.length && (l = k(l, f ? d : sjcl.mode.ocb2.pmac(a, d)));\n    if (!h.equal(h.clamp(l, e), h.bitSlice(b, r))) throw new sjcl.exception.corrupt(\"ocb: tag doesn't match\");\n    return q.concat(h.clamp(m, p));\n  },\n  pmac: function pmac(a, b) {\n    var c,\n      d = sjcl.mode.ocb2.S,\n      e = sjcl.bitArray,\n      f = e.i,\n      g = [0, 0, 0, 0],\n      h = a.encrypt([0, 0, 0, 0]),\n      h = f(h, d(d(h)));\n    for (c = 0; c + 4 < b.length; c += 4) {\n      h = d(h), g = f(g, a.encrypt(f(h, b.slice(c, c + 4))));\n    }\n    c = b.slice(c);\n    128 > e.bitLength(c) && (h = f(h, d(h)), c = e.concat(c, [-2147483648, 0, 0, 0]));\n    g = f(g, c);\n    return a.encrypt(f(d(f(h, d(h))), g));\n  },\n  S: function S(a) {\n    return [a[0] << 1 ^ a[1] >>> 31, a[1] << 1 ^ a[2] >>> 31, a[2] << 1 ^ a[3] >>> 31, a[3] << 1 ^ 135 * (a[0] >>> 31)];\n  }\n};\nsjcl.mode.gcm = {\n  name: \"gcm\",\n  encrypt: function encrypt(a, b, c, d, e) {\n    var f = b.slice(0);\n    b = sjcl.bitArray;\n    d = d || [];\n    a = sjcl.mode.gcm.C(!0, a, f, d, c, e || 128);\n    return b.concat(a.data, a.tag);\n  },\n  decrypt: function decrypt(a, b, c, d, e) {\n    var f = b.slice(0),\n      g = sjcl.bitArray,\n      h = g.bitLength(f);\n    e = e || 128;\n    d = d || [];\n    e <= h ? (b = g.bitSlice(f, h - e), f = g.bitSlice(f, 0, h - e)) : (b = f, f = []);\n    a = sjcl.mode.gcm.C(!1, a, f, d, c, e);\n    if (!g.equal(a.tag, b)) throw new sjcl.exception.corrupt(\"gcm: tag doesn't match\");\n    return a.data;\n  },\n  ka: function ka(a, b) {\n    var c,\n      d,\n      e,\n      f,\n      g,\n      h = sjcl.bitArray.i;\n    e = [0, 0, 0, 0];\n    f = b.slice(0);\n    for (c = 0; 128 > c; c++) {\n      (d = 0 !== (a[Math.floor(c / 32)] & 1 << 31 - c % 32)) && (e = h(e, f));\n      g = 0 !== (f[3] & 1);\n      for (d = 3; 0 < d; d--) {\n        f[d] = f[d] >>> 1 | (f[d - 1] & 1) << 31;\n      }\n      f[0] >>>= 1;\n      g && (f[0] ^= -0x1f000000);\n    }\n    return e;\n  },\n  j: function j(a, b, c) {\n    var d,\n      e = c.length;\n    b = b.slice(0);\n    for (d = 0; d < e; d += 4) {\n      b[0] ^= 0xffffffff & c[d], b[1] ^= 0xffffffff & c[d + 1], b[2] ^= 0xffffffff & c[d + 2], b[3] ^= 0xffffffff & c[d + 3], b = sjcl.mode.gcm.ka(b, a);\n    }\n    return b;\n  },\n  C: function C(a, b, c, d, e, f) {\n    var g,\n      h,\n      k,\n      l,\n      n,\n      m,\n      p,\n      r,\n      q = sjcl.bitArray;\n    m = c.length;\n    p = q.bitLength(c);\n    r = q.bitLength(d);\n    h = q.bitLength(e);\n    g = b.encrypt([0, 0, 0, 0]);\n    96 === h ? (e = e.slice(0), e = q.concat(e, [1])) : (e = sjcl.mode.gcm.j(g, [0, 0, 0, 0], e), e = sjcl.mode.gcm.j(g, e, [0, 0, Math.floor(h / 0x100000000), h & 0xffffffff]));\n    h = sjcl.mode.gcm.j(g, [0, 0, 0, 0], d);\n    n = e.slice(0);\n    d = h.slice(0);\n    a || (d = sjcl.mode.gcm.j(g, h, c));\n    for (l = 0; l < m; l += 4) {\n      n[3]++, k = b.encrypt(n), c[l] ^= k[0], c[l + 1] ^= k[1], c[l + 2] ^= k[2], c[l + 3] ^= k[3];\n    }\n    c = q.clamp(c, p);\n    a && (d = sjcl.mode.gcm.j(g, h, c));\n    a = [Math.floor(r / 0x100000000), r & 0xffffffff, Math.floor(p / 0x100000000), p & 0xffffffff];\n    d = sjcl.mode.gcm.j(g, d, a);\n    k = b.encrypt(e);\n    d[0] ^= k[0];\n    d[1] ^= k[1];\n    d[2] ^= k[2];\n    d[3] ^= k[3];\n    return {\n      tag: q.bitSlice(d, 0, f),\n      data: c\n    };\n  }\n};\nsjcl.misc.hmac = function (a, b) {\n  this.W = b = b || sjcl.hash.sha256;\n  var c = [[], []],\n    d,\n    e = b.prototype.blockSize / 32;\n  this.w = [new b(), new b()];\n  a.length > e && (a = b.hash(a));\n  for (d = 0; d < e; d++) {\n    c[0][d] = a[d] ^ 909522486, c[1][d] = a[d] ^ 1549556828;\n  }\n  this.w[0].update(c[0]);\n  this.w[1].update(c[1]);\n  this.R = new b(this.w[0]);\n};\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (a) {\n  if (this.aa) throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  this.update(a);\n  return this.digest(a);\n};\nsjcl.misc.hmac.prototype.reset = function () {\n  this.R = new this.W(this.w[0]);\n  this.aa = !1;\n};\nsjcl.misc.hmac.prototype.update = function (a) {\n  this.aa = !0;\n  this.R.update(a);\n};\nsjcl.misc.hmac.prototype.digest = function () {\n  var a = this.R.finalize(),\n    a = new this.W(this.w[1]).update(a).finalize();\n  this.reset();\n  return a;\n};\nsjcl.misc.pbkdf2 = function (a, b, c, d, e) {\n  c = c || 1E4;\n  if (0 > d || 0 > c) throw new sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  \"string\" === typeof a && (a = sjcl.codec.utf8String.toBits(a));\n  \"string\" === typeof b && (b = sjcl.codec.utf8String.toBits(b));\n  e = e || sjcl.misc.hmac;\n  a = new e(a);\n  var f,\n    g,\n    h,\n    k,\n    l = [],\n    n = sjcl.bitArray;\n  for (k = 1; 32 * l.length < (d || 1); k++) {\n    e = f = a.encrypt(n.concat(b, [k]));\n    for (g = 1; g < c; g++) {\n      for (f = a.encrypt(f), h = 0; h < f.length; h++) {\n        e[h] ^= f[h];\n      }\n    }\n    l = l.concat(e);\n  }\n  d && (l = n.clamp(l, d));\n  return l;\n};\nsjcl.prng = function (a) {\n  this.c = [new sjcl.hash.sha256()];\n  this.m = [0];\n  this.P = 0;\n  this.H = {};\n  this.N = 0;\n  this.U = {};\n  this.Z = this.f = this.o = this.ha = 0;\n  this.b = [0, 0, 0, 0, 0, 0, 0, 0];\n  this.h = [0, 0, 0, 0];\n  this.L = void 0;\n  this.M = a;\n  this.D = !1;\n  this.K = {\n    progress: {},\n    seeded: {}\n  };\n  this.u = this.ga = 0;\n  this.I = 1;\n  this.J = 2;\n  this.ca = 0x10000;\n  this.T = [0, 48, 64, 96, 128, 192, 0x100, 384, 512, 768, 1024];\n  this.da = 3E4;\n  this.ba = 80;\n};\nsjcl.prng.prototype = {\n  randomWords: function randomWords(a, b) {\n    var c = [],\n      d;\n    d = this.isReady(b);\n    var e;\n    if (d === this.u) throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    if (d & this.J) {\n      d = !(d & this.I);\n      e = [];\n      var f = 0,\n        g;\n      this.Z = e[0] = new Date().valueOf() + this.da;\n      for (g = 0; 16 > g; g++) {\n        e.push(0x100000000 * Math.random() | 0);\n      }\n      for (g = 0; g < this.c.length && (e = e.concat(this.c[g].finalize()), f += this.m[g], this.m[g] = 0, d || !(this.P & 1 << g)); g++) {\n        ;\n      }\n      this.P >= 1 << this.c.length && (this.c.push(new sjcl.hash.sha256()), this.m.push(0));\n      this.f -= f;\n      f > this.o && (this.o = f);\n      this.P++;\n      this.b = sjcl.hash.sha256.hash(this.b.concat(e));\n      this.L = new sjcl.cipher.aes(this.b);\n      for (d = 0; 4 > d && (this.h[d] = this.h[d] + 1 | 0, !this.h[d]); d++) {\n        ;\n      }\n    }\n    for (d = 0; d < a; d += 4) {\n      0 === (d + 1) % this.ca && y(this), e = z(this), c.push(e[0], e[1], e[2], e[3]);\n    }\n    y(this);\n    return c.slice(0, a);\n  },\n  setDefaultParanoia: function setDefaultParanoia(a, b) {\n    if (0 === a && \"Setting paranoia=0 will ruin your security; use it only for testing\" !== b) throw new sjcl.exception.invalid(\"Setting paranoia=0 will ruin your security; use it only for testing\");\n    this.M = a;\n  },\n  addEntropy: function addEntropy(a, b, c) {\n    c = c || \"user\";\n    var d,\n      e,\n      f = new Date().valueOf(),\n      g = this.H[c],\n      h = this.isReady(),\n      k = 0;\n    d = this.U[c];\n    void 0 === d && (d = this.U[c] = this.ha++);\n    void 0 === g && (g = this.H[c] = 0);\n    this.H[c] = (this.H[c] + 1) % this.c.length;\n    switch (typeof a) {\n      case \"number\":\n        void 0 === b && (b = 1);\n        this.c[g].update([d, this.N++, 1, b, f, 1, a | 0]);\n        break;\n      case \"object\":\n        c = Object.prototype.toString.call(a);\n        if (\"[object Uint32Array]\" === c) {\n          e = [];\n          for (c = 0; c < a.length; c++) {\n            e.push(a[c]);\n          }\n          a = e;\n        } else for (\"[object Array]\" !== c && (k = 1), c = 0; c < a.length && !k; c++) {\n          \"number\" !== typeof a[c] && (k = 1);\n        }\n        if (!k) {\n          if (void 0 === b) for (c = b = 0; c < a.length; c++) {\n            for (e = a[c]; 0 < e;) {\n              b++, e = e >>> 1;\n            }\n          }\n          this.c[g].update([d, this.N++, 2, b, f, a.length].concat(a));\n        }\n        break;\n      case \"string\":\n        void 0 === b && (b = a.length);\n        this.c[g].update([d, this.N++, 3, b, f, a.length]);\n        this.c[g].update(a);\n        break;\n      default:\n        k = 1;\n    }\n    if (k) throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    this.m[g] += b;\n    this.f += b;\n    h === this.u && (this.isReady() !== this.u && A(\"seeded\", Math.max(this.o, this.f)), A(\"progress\", this.getProgress()));\n  },\n  isReady: function isReady(a) {\n    a = this.T[void 0 !== a ? a : this.M];\n    return this.o && this.o >= a ? this.m[0] > this.ba && new Date().valueOf() > this.Z ? this.J | this.I : this.I : this.f >= a ? this.J | this.u : this.u;\n  },\n  getProgress: function getProgress(a) {\n    a = this.T[a ? a : this.M];\n    return this.o >= a ? 1 : this.f > a ? 1 : this.f / a;\n  },\n  startCollectors: function startCollectors() {\n    if (!this.D) {\n      this.a = {\n        loadTimeCollector: B(this, this.ma),\n        mouseCollector: B(this, this.oa),\n        keyboardCollector: B(this, this.la),\n        accelerometerCollector: B(this, this.ea),\n        touchCollector: B(this, this.qa)\n      };\n      if (window.addEventListener) window.addEventListener(\"load\", this.a.loadTimeCollector, !1), window.addEventListener(\"mousemove\", this.a.mouseCollector, !1), window.addEventListener(\"keypress\", this.a.keyboardCollector, !1), window.addEventListener(\"devicemotion\", this.a.accelerometerCollector, !1), window.addEventListener(\"touchmove\", this.a.touchCollector, !1);else if (document.attachEvent) document.attachEvent(\"onload\", this.a.loadTimeCollector), document.attachEvent(\"onmousemove\", this.a.mouseCollector), document.attachEvent(\"keypress\", this.a.keyboardCollector);else throw new sjcl.exception.bug(\"can't attach event\");\n      this.D = !0;\n    }\n  },\n  stopCollectors: function stopCollectors() {\n    this.D && (window.removeEventListener ? (window.removeEventListener(\"load\", this.a.loadTimeCollector, !1), window.removeEventListener(\"mousemove\", this.a.mouseCollector, !1), window.removeEventListener(\"keypress\", this.a.keyboardCollector, !1), window.removeEventListener(\"devicemotion\", this.a.accelerometerCollector, !1), window.removeEventListener(\"touchmove\", this.a.touchCollector, !1)) : document.detachEvent && (document.detachEvent(\"onload\", this.a.loadTimeCollector), document.detachEvent(\"onmousemove\", this.a.mouseCollector), document.detachEvent(\"keypress\", this.a.keyboardCollector)), this.D = !1);\n  },\n  addEventListener: function addEventListener(a, b) {\n    this.K[a][this.ga++] = b;\n  },\n  removeEventListener: function removeEventListener(a, b) {\n    var c,\n      d,\n      e = this.K[a],\n      f = [];\n    for (d in e) {\n      e.hasOwnProperty(d) && e[d] === b && f.push(d);\n    }\n    for (c = 0; c < f.length; c++) {\n      d = f[c], delete e[d];\n    }\n  },\n  la: function la() {\n    C(this, 1);\n  },\n  oa: function oa(a) {\n    var b, c;\n    try {\n      b = a.x || a.clientX || a.offsetX || 0, c = a.y || a.clientY || a.offsetY || 0;\n    } catch (d) {\n      c = b = 0;\n    }\n    0 != b && 0 != c && this.addEntropy([b, c], 2, \"mouse\");\n    C(this, 0);\n  },\n  qa: function qa(a) {\n    a = a.touches[0] || a.changedTouches[0];\n    this.addEntropy([a.pageX || a.clientX, a.pageY || a.clientY], 1, \"touch\");\n    C(this, 0);\n  },\n  ma: function ma() {\n    C(this, 2);\n  },\n  ea: function ea(a) {\n    a = a.accelerationIncludingGravity.x || a.accelerationIncludingGravity.y || a.accelerationIncludingGravity.z;\n    if (window.orientation) {\n      var b = window.orientation;\n      \"number\" === typeof b && this.addEntropy(b, 1, \"accelerometer\");\n    }\n    a && this.addEntropy(a, 2, \"accelerometer\");\n    C(this, 0);\n  }\n};\nfunction A(a, b) {\n  var c,\n    d = sjcl.random.K[a],\n    e = [];\n  for (c in d) {\n    d.hasOwnProperty(c) && e.push(d[c]);\n  }\n  for (c = 0; c < e.length; c++) {\n    e[c](b);\n  }\n}\nfunction C(a, b) {\n  \"undefined\" !== typeof window && window.performance && \"function\" === typeof window.performance.now ? a.addEntropy(window.performance.now(), b, \"loadtime\") : a.addEntropy(new Date().valueOf(), b, \"loadtime\");\n}\nfunction y(a) {\n  a.b = z(a).concat(z(a));\n  a.L = new sjcl.cipher.aes(a.b);\n}\nfunction z(a) {\n  for (var b = 0; 4 > b && (a.h[b] = a.h[b] + 1 | 0, !a.h[b]); b++) {\n    ;\n  }\n  return a.L.encrypt(a.h);\n}\nfunction B(a, b) {\n  return function () {\n    b.apply(a, arguments);\n  };\n}\nsjcl.random = new sjcl.prng(6);\na: try {\n  var D, E, F, G;\n  if (G = \"undefined\" !== typeof module && module.exports) {\n    var H;\n    try {\n      H = require(\"crypto\");\n    } catch (a) {\n      H = null;\n    }\n    G = E = H;\n  }\n  if (G && E.randomBytes) D = E.randomBytes(128), D = new Uint32Array(new Uint8Array(D).buffer), sjcl.random.addEntropy(D, 1024, \"crypto['randomBytes']\");else if (\"undefined\" !== typeof window && \"undefined\" !== typeof Uint32Array) {\n    F = new Uint32Array(32);\n    if (window.crypto && window.crypto.getRandomValues) window.crypto.getRandomValues(F);else if (window.msCrypto && window.msCrypto.getRandomValues) window.msCrypto.getRandomValues(F);else break a;\n    sjcl.random.addEntropy(F, 1024, \"crypto['getRandomValues']\");\n  }\n} catch (a) {\n  \"undefined\" !== typeof window && window.console && (console.log(\"There was an error collecting entropy from the browser:\"), console.log(a));\n}\nsjcl.json = {\n  defaults: {\n    v: 1,\n    iter: 1E4,\n    ks: 128,\n    ts: 64,\n    mode: \"ccm\",\n    adata: \"\",\n    cipher: \"aes\"\n  },\n  ja: function ja(a, b, c, d) {\n    c = c || {};\n    d = d || {};\n    var e = sjcl.json,\n      f = e.g({\n        iv: sjcl.random.randomWords(4, 0)\n      }, e.defaults),\n      g;\n    e.g(f, c);\n    c = f.adata;\n    \"string\" === typeof f.salt && (f.salt = sjcl.codec.base64.toBits(f.salt));\n    \"string\" === typeof f.iv && (f.iv = sjcl.codec.base64.toBits(f.iv));\n    if (!sjcl.mode[f.mode] || !sjcl.cipher[f.cipher] || \"string\" === typeof a && 100 >= f.iter || 64 !== f.ts && 96 !== f.ts && 128 !== f.ts || 128 !== f.ks && 192 !== f.ks && 0x100 !== f.ks || 2 > f.iv.length || 4 < f.iv.length) throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    \"string\" === typeof a ? (g = sjcl.misc.cachedPbkdf2(a, f), a = g.key.slice(0, f.ks / 32), f.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.publicKey && (g = a.kem(), f.kemtag = g.tag, a = g.key.slice(0, f.ks / 32));\n    \"string\" === typeof b && (b = sjcl.codec.utf8String.toBits(b));\n    \"string\" === typeof c && (f.adata = c = sjcl.codec.utf8String.toBits(c));\n    g = new sjcl.cipher[f.cipher](a);\n    e.g(d, f);\n    d.key = a;\n    f.ct = \"ccm\" === f.mode && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && b instanceof ArrayBuffer ? sjcl.arrayBuffer.ccm.encrypt(g, b, f.iv, c, f.ts) : sjcl.mode[f.mode].encrypt(g, b, f.iv, c, f.ts);\n    return f;\n  },\n  encrypt: function encrypt(a, b, c, d) {\n    var e = sjcl.json,\n      f = e.ja.apply(e, arguments);\n    return e.encode(f);\n  },\n  ia: function ia(a, b, c, d) {\n    c = c || {};\n    d = d || {};\n    var e = sjcl.json;\n    b = e.g(e.g(e.g({}, e.defaults), b), c, !0);\n    var f, g;\n    f = b.adata;\n    \"string\" === typeof b.salt && (b.salt = sjcl.codec.base64.toBits(b.salt));\n    \"string\" === typeof b.iv && (b.iv = sjcl.codec.base64.toBits(b.iv));\n    if (!sjcl.mode[b.mode] || !sjcl.cipher[b.cipher] || \"string\" === typeof a && 100 >= b.iter || 64 !== b.ts && 96 !== b.ts && 128 !== b.ts || 128 !== b.ks && 192 !== b.ks && 0x100 !== b.ks || !b.iv || 2 > b.iv.length || 4 < b.iv.length) throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    \"string\" === typeof a ? (g = sjcl.misc.cachedPbkdf2(a, b), a = g.key.slice(0, b.ks / 32), b.salt = g.salt) : sjcl.ecc && a instanceof sjcl.ecc.elGamal.secretKey && (a = a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0, b.ks / 32));\n    \"string\" === typeof f && (f = sjcl.codec.utf8String.toBits(f));\n    g = new sjcl.cipher[b.cipher](a);\n    f = \"ccm\" === b.mode && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && b.ct instanceof ArrayBuffer ? sjcl.arrayBuffer.ccm.decrypt(g, b.ct, b.iv, b.tag, f, b.ts) : sjcl.mode[b.mode].decrypt(g, b.ct, b.iv, f, b.ts);\n    e.g(d, b);\n    d.key = a;\n    return 1 === c.raw ? f : sjcl.codec.utf8String.fromBits(f);\n  },\n  decrypt: function decrypt(a, b, c, d) {\n    var e = sjcl.json;\n    return e.ia(a, e.decode(b), c, d);\n  },\n  encode: function encode(a) {\n    var b,\n      c = \"{\",\n      d = \"\";\n    for (b in a) {\n      if (a.hasOwnProperty(b)) {\n        if (!b.match(/^[a-z0-9]+$/i)) throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        c += d + '\"' + b + '\":';\n        d = \",\";\n        switch (typeof a[b]) {\n          case \"number\":\n          case \"boolean\":\n            c += a[b];\n            break;\n          case \"string\":\n            c += '\"' + escape(a[b]) + '\"';\n            break;\n          case \"object\":\n            c += '\"' + sjcl.codec.base64.fromBits(a[b], 0) + '\"';\n            break;\n          default:\n            throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n    return c + \"}\";\n  },\n  decode: function decode(a) {\n    a = a.replace(/\\s/g, \"\");\n    if (!a.match(/^\\{.*\\}$/)) throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    a = a.replace(/^\\{|\\}$/g, \"\").split(/,/);\n    var b = {},\n      c,\n      d;\n    for (c = 0; c < a.length; c++) {\n      if (!(d = a[c].match(/^\\s*(?:([\"']?)([a-z][a-z0-9]*)\\1)\\s*:\\s*(?:(-?\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\"|(true|false))$/i))) throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      null != d[3] ? b[d[2]] = parseInt(d[3], 10) : null != d[4] ? b[d[2]] = d[2].match(/^(ct|adata|salt|iv)$/) ? sjcl.codec.base64.toBits(d[4]) : unescape(d[4]) : null != d[5] && (b[d[2]] = \"true\" === d[5]);\n    }\n    return b;\n  },\n  g: function g(a, b, c) {\n    void 0 === a && (a = {});\n    if (void 0 === b) return a;\n    for (var d in b) {\n      if (b.hasOwnProperty(d)) {\n        if (c && void 0 !== a[d] && a[d] !== b[d]) throw new sjcl.exception.invalid(\"required parameter overridden\");\n        a[d] = b[d];\n      }\n    }\n    return a;\n  },\n  sa: function sa(a, b) {\n    var c = {},\n      d;\n    for (d in a) {\n      a.hasOwnProperty(d) && a[d] !== b[d] && (c[d] = a[d]);\n    }\n    return c;\n  },\n  ra: function ra(a, b) {\n    var c = {},\n      d;\n    for (d = 0; d < b.length; d++) {\n      void 0 !== a[b[d]] && (c[b[d]] = a[b[d]]);\n    }\n    return c;\n  }\n};\nsjcl.encrypt = sjcl.json.encrypt;\nsjcl.decrypt = sjcl.json.decrypt;\nsjcl.misc.pa = {};\nsjcl.misc.cachedPbkdf2 = function (a, b) {\n  var c = sjcl.misc.pa,\n    d;\n  b = b || {};\n  d = b.iter || 1E3;\n  c = c[a] = c[a] || {};\n  d = c[d] = c[d] || {\n    firstSalt: b.salt && b.salt.length ? b.salt.slice(0) : sjcl.random.randomWords(2, 0)\n  };\n  c = void 0 === b.salt ? d.firstSalt : b.salt;\n  d[c] = d[c] || sjcl.misc.pbkdf2(a, c, b.iter);\n  return {\n    key: d[c].slice(0),\n    salt: c.slice(0)\n  };\n};\n\"undefined\" !== typeof module && module.exports && (module.exports = sjcl);\n\"function\" === typeof define && define([], function () {\n  return sjcl;\n});","map":null,"metadata":{},"sourceType":"script"}