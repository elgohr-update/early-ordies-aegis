{"ast":null,"code":"var _classCallCheck = require(\"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _inherits = require(\"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar _possibleConstructorReturn = require(\"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar _require = require('readable-stream'),\n  Transform = _require.Transform;\nmodule.exports = function (KeccakState) {\n  return /*#__PURE__*/function (_Transform) {\n    \"use strict\";\n\n    _inherits(Keccak, _Transform);\n    var _super = _createSuper(Keccak);\n    function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {\n      var _this;\n      _classCallCheck(this, Keccak);\n      _this = _super.call(this, options);\n      _this._rate = rate;\n      _this._capacity = capacity;\n      _this._delimitedSuffix = delimitedSuffix;\n      _this._hashBitLength = hashBitLength;\n      _this._options = options;\n      _this._state = new KeccakState();\n      _this._state.initialize(rate, capacity);\n      _this._finalized = false;\n      return _this;\n    }\n    _createClass(Keccak, [{\n      key: \"_transform\",\n      value: function _transform(chunk, encoding, callback) {\n        var error = null;\n        try {\n          this.update(chunk, encoding);\n        } catch (err) {\n          error = err;\n        }\n        callback(error);\n      }\n    }, {\n      key: \"_flush\",\n      value: function _flush(callback) {\n        var error = null;\n        try {\n          this.push(this.digest());\n        } catch (err) {\n          error = err;\n        }\n        callback(error);\n      }\n    }, {\n      key: \"update\",\n      value: function update(data, encoding) {\n        if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');\n        if (this._finalized) throw new Error('Digest already called');\n        if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);\n        this._state.absorb(data);\n        return this;\n      }\n    }, {\n      key: \"digest\",\n      value: function digest(encoding) {\n        if (this._finalized) throw new Error('Digest already called');\n        this._finalized = true;\n        if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);\n        var digest = this._state.squeeze(this._hashBitLength / 8);\n        if (encoding !== undefined) digest = digest.toString(encoding);\n        this._resetState();\n        return digest;\n      }\n\n      // remove result from memory\n    }, {\n      key: \"_resetState\",\n      value: function _resetState() {\n        this._state.initialize(this._rate, this._capacity);\n        return this;\n      }\n\n      // because sometimes we need hash right now and little later\n    }, {\n      key: \"_clone\",\n      value: function _clone() {\n        var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);\n        this._state.copy(clone._state);\n        clone._finalized = this._finalized;\n        return clone;\n      }\n    }]);\n    return Keccak;\n  }(Transform);\n};","map":null,"metadata":{},"sourceType":"script"}