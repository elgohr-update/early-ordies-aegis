{"ast":null,"code":"import _asyncToGenerator from \"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/cryptodev/Dev/aegis-burner/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"/home/cryptodev/Dev/aegis-burner/src/contexts/Nocust.js\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nimport React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect } from 'react';\nimport { NOCUSTManager } from 'nocust-client';\n//import { createNocustManager } from '../services/nocustManager'\nimport { nocust } from 'nocust-client';\nimport Web3 from 'web3';\nvar HUB_CONTRACT_ADDRESS = process.env.REACT_APP_HUB_CONTRACT_ADDRESS;\nvar WEB3_PROVIDER = process.env.REACT_APP_WEB3_PROVIDER;\nvar HUB_API_URL = process.env.REACT_APP_HUB_API_URL;\n\n//console.log('HUB_CONTRACT_ADDRESS', HUB_CONTRACT_ADDRESS)\n//console.log('WEB3_PROVIDER', WEB3_PROVIDER)\n//console.log('HUB_API_URL', HUB_API_URL)\n\nvar INITIAL_HUB_INFO = {\n  hubContract: HUB_CONTRACT_ADDRESS,\n  hubApiUrl: HUB_API_URL\n};\nvar UPDATE_ERA = 'UPDATE_ERA';\nvar UPDATE_NOCUST = 'UPDATE_NOCUST';\nvar UPDATE_RECOVERY = 'UPDATE_RECOVERY';\nvar UPDATE_SLA = 'UPDATE_SLA';\nexport var NocustContext = createContext();\nexport function useNocustContext() {\n  return useContext(NocustContext);\n}\nfunction reducer(state, _ref) {\n  var type = _ref.type,\n    payload = _ref.payload;\n  switch (type) {\n    case UPDATE_NOCUST:\n      {\n        var _nocust = payload.nocust;\n        return _objectSpread({}, state, {\n          nocust: _nocust\n        });\n      }\n    case UPDATE_ERA:\n      {\n        var eraNumber = payload.eraNumber;\n        return _objectSpread({}, state, {\n          eraNumber: eraNumber\n        });\n      }\n    case UPDATE_RECOVERY:\n      {\n        var isRecovery = payload.isRecovery;\n        return _objectSpread({}, state, {\n          isRecovery: isRecovery\n        });\n      }\n    case UPDATE_SLA:\n      {\n        var slaDetail = payload.slaDetail;\n        return _objectSpread({}, state, {\n          slaDetail: slaDetail\n        });\n      }\n    default:\n      {\n        throw Error(\"Unexpected action type in NocustContext reducer: '\".concat(type, \"'.\"));\n      }\n  }\n}\nexport default function Provider(_ref2) {\n  var web3 = _ref2.web3,\n    children = _ref2.children;\n  var _useReducer = useReducer(reducer, {\n      web3: web3,\n      hub: INITIAL_HUB_INFO\n    }),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    state = _useReducer2[0],\n    dispatch = _useReducer2[1];\n  var updateNocust = useCallback(function (nocust) {\n    dispatch({\n      type: UPDATE_NOCUST,\n      payload: {\n        nocust: nocust\n      }\n    });\n  }, []);\n  var updateEra = useCallback(function (eraNumber) {\n    dispatch({\n      type: UPDATE_ERA,\n      payload: {\n        eraNumber: eraNumber\n      }\n    });\n  }, []);\n  var updateIsRecovery = useCallback(function (isRecovery) {\n    dispatch({\n      type: UPDATE_RECOVERY,\n      payload: {\n        isRecovery: isRecovery\n      }\n    });\n  }, []);\n  var updateSlaDetail = useCallback(function (isRecovery) {\n    dispatch({\n      type: UPDATE_SLA,\n      payload: {\n        isRecovery: isRecovery\n      }\n    });\n  }, []);\n\n  // Poll the hub to keep track of the Era number\n  // Can then use it as a clock to avoid excessive requests to hub\n  useEffect(function () {\n    var test = function test() {\n      var nocust = state.nocust;\n      if (nocust) {\n        console.log('Checking Era');\n        nocust.getEraNumber().then(function (eraNumber) {\n          console.log('Era:', eraNumber);\n          updateEra(eraNumber);\n        }).catch(function () {\n          console.log('setting eraNumber to null');\n          updateEra(null);\n        });\n      }\n    };\n    test();\n    var intervalId = setInterval(test, 10000);\n    return function () {\n      clearInterval(intervalId);\n    };\n  }, [state.nocust]);\n  return /*#__PURE__*/React.createElement(NocustContext.Provider, {\n    value: useMemo(function () {\n      return [state, {\n        updateNocust: updateNocust,\n        updateEra: updateEra,\n        updateIsRecovery: updateIsRecovery,\n        updateSlaDetail: updateSlaDetail\n      }];\n    }, [state, updateNocust, updateEra, updateIsRecovery, updateSlaDetail]),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useNocustHubInfo() {\n  var _useNocustContext = useNocustContext(),\n    _useNocustContext2 = _slicedToArray(_useNocustContext, 1),\n    state = _useNocustContext2[0];\n  var hub = state.hub;\n  return hub;\n}\nexport function getBlocksPerEon() {\n  var _useNocustContext3 = useNocustContext(),\n    _useNocustContext4 = _slicedToArray(_useNocustContext3, 2),\n    state = _useNocustContext4[0],\n    updateBlocksPerEon = _useNocustContext4[1].updateBlocksPerEon;\n  var nocust = state.nocust,\n    blocksPerEon = state.blocksPerEon;\n  useEffect(function () {\n    if (nocust) {\n      nocust.getBlocksPerEon().then(function (blocksPerEon) {\n        return updateBlocksPerEon(blocksPerEon);\n      }).catch(function () {\n        return updateBlocksPerEon(null);\n      });\n    }\n  }, [nocust]);\n  console.log(state);\n  return blocksPerEon;\n}\n\n//Old NOCUST\nexport function useNocustClient() {\n  var _useNocustContext5 = useNocustContext(),\n    _useNocustContext6 = _slicedToArray(_useNocustContext5, 2),\n    state = _useNocustContext6[0],\n    updateNocust = _useNocustContext6[1].updateNocust;\n  var web3 = state.web3,\n    nocust = state.nocust;\n  useEffect(function () {\n    if (web3 && !nocust) {\n      try {\n        var nocustManager = new NOCUSTManager({\n          rpcApi: web3,\n          operatorApiUrl: HUB_API_URL,\n          contractAddress: HUB_CONTRACT_ADDRESS\n        });\n        updateNocust(nocustManager);\n        console.log('new nocust-client');\n      } catch (e) {\n        updateNocust(null);\n        console.log('no nocust-client');\n      }\n    }\n  });\n  return nocust;\n}\nexport function useIsRecovery() {\n  var _useNocustContext7 = useNocustContext(),\n    _useNocustContext8 = _slicedToArray(_useNocustContext7, 2),\n    state = _useNocustContext8[0],\n    updateIsRecovery = _useNocustContext8[1].updateIsRecovery; //const { nocust, isRecovery, eraNumber } = state\n  var isRecovery = state.isRecovery,\n    eraNumber = state.eraNumber,\n    privateKey = state.privateKey;\n  console.log('pk', privateKey);\n  useEffect(function () {\n    var checkIsRecovery = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var recoveryMode;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return nocust.init({\n                  contractAddress: HUB_CONTRACT_ADDRESS,\n                  rpcUrl: WEB3_PROVIDER,\n                  operatorUrl: HUB_API_URL\n                });\n              case 2:\n                _context.next = 4;\n                return nocust.addPrivateKey(privateKey);\n              case 4:\n                console.log(\"Private key added\");\n                _context.next = 7;\n                return nocust.isRecoveryMode();\n              case 7:\n                recoveryMode = _context.sent;\n                recoveryMode.then(function (isRecovery) {\n                  return updateIsRecovery(isRecovery);\n                }).catch(function () {\n                  return updateIsRecovery(false);\n                });\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function checkIsRecovery() {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    checkIsRecovery();\n  }, [eraNumber]);\n  return isRecovery;\n}\nexport function useEraNumber() {\n  var _useNocustContext9 = useNocustContext(),\n    _useNocustContext10 = _slicedToArray(_useNocustContext9, 1),\n    state = _useNocustContext10[0];\n  var eraNumber = state.eraNumber;\n  return eraNumber;\n}\nexport function useSlaDetail(address) {\n  var _useNocustContext11 = useNocustContext(),\n    _useNocustContext12 = _slicedToArray(_useNocustContext11, 2),\n    state = _useNocustContext12[0],\n    updateSlaDetail = _useNocustContext12[1].updateSlaDetail;\n  var nocust = state.nocust,\n    eraNumber = state.eraNumber,\n    slaDetail = state.slaDetail;\n  useEffect(function () {\n    if (nocust) {\n      nocust.getSLADetail().then(function (slaDetail) {\n        return updateSlaDetail(slaDetail);\n      }).catch(function (slaDetail) {\n        return updateSlaDetail({});\n      });\n    }\n  }, [address, eraNumber]);\n  return slaDetail;\n}","map":{"version":3,"names":["React","createContext","useContext","useReducer","useMemo","useCallback","useEffect","NOCUSTManager","nocust","Web3","HUB_CONTRACT_ADDRESS","process","env","REACT_APP_HUB_CONTRACT_ADDRESS","WEB3_PROVIDER","REACT_APP_WEB3_PROVIDER","HUB_API_URL","REACT_APP_HUB_API_URL","INITIAL_HUB_INFO","hubContract","hubApiUrl","UPDATE_ERA","UPDATE_NOCUST","UPDATE_RECOVERY","UPDATE_SLA","NocustContext","useNocustContext","reducer","state","type","payload","eraNumber","isRecovery","slaDetail","Error","Provider","web3","children","hub","dispatch","updateNocust","updateEra","updateIsRecovery","updateSlaDetail","test","console","log","getEraNumber","then","catch","intervalId","setInterval","clearInterval","useNocustHubInfo","getBlocksPerEon","updateBlocksPerEon","blocksPerEon","useNocustClient","nocustManager","rpcApi","operatorApiUrl","contractAddress","e","useIsRecovery","privateKey","checkIsRecovery","init","rpcUrl","operatorUrl","addPrivateKey","isRecoveryMode","recoveryMode","useEraNumber","useSlaDetail","address","getSLADetail"],"sources":["/home/cryptodev/Dev/aegis-burner/src/contexts/Nocust.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect } from 'react'\n\nimport { NOCUSTManager } from 'nocust-client'\n//import { createNocustManager } from '../services/nocustManager'\nimport { nocust } from 'nocust-client'\nimport Web3 from 'web3'\n\nconst HUB_CONTRACT_ADDRESS = process.env.REACT_APP_HUB_CONTRACT_ADDRESS\nconst WEB3_PROVIDER = process.env.REACT_APP_WEB3_PROVIDER\nconst HUB_API_URL = process.env.REACT_APP_HUB_API_URL\n\n//console.log('HUB_CONTRACT_ADDRESS', HUB_CONTRACT_ADDRESS)\n//console.log('WEB3_PROVIDER', WEB3_PROVIDER)\n//console.log('HUB_API_URL', HUB_API_URL)\n\nconst INITIAL_HUB_INFO = {\n  hubContract: HUB_CONTRACT_ADDRESS,\n  hubApiUrl: HUB_API_URL\n}\n\nconst UPDATE_ERA = 'UPDATE_ERA'\nconst UPDATE_NOCUST = 'UPDATE_NOCUST'\nconst UPDATE_RECOVERY = 'UPDATE_RECOVERY'\nconst UPDATE_SLA = 'UPDATE_SLA'\n\nexport const NocustContext = createContext()\n\nexport function useNocustContext () {\n  return useContext(NocustContext)\n}\n\nfunction reducer (state, { type, payload }) {\n  switch (type) {\n    case UPDATE_NOCUST: {\n      const { nocust } = payload\n      return {\n        ...state,\n        nocust\n      }\n    }\n    case UPDATE_ERA: {\n      const { eraNumber } = payload\n      return {\n        ...state,\n        eraNumber\n      }\n    }\n    case UPDATE_RECOVERY: {\n      const { isRecovery } = payload\n      return {\n        ...state,\n        isRecovery\n      }\n    }\n    case UPDATE_SLA: {\n      const { slaDetail } = payload\n      return {\n        ...state,\n        slaDetail\n      }\n    }\n    default: {\n      throw Error(`Unexpected action type in NocustContext reducer: '${type}'.`)\n    }\n  }\n}\n\nexport default function Provider ({ web3, children }) {\n  const [state, dispatch] = useReducer(reducer, { web3: web3, hub: INITIAL_HUB_INFO })\n\n  const updateNocust = useCallback((nocust) => {\n    dispatch({ type: UPDATE_NOCUST, payload: { nocust } })\n  }, [])\n\n  const updateEra = useCallback((eraNumber) => {\n    dispatch({ type: UPDATE_ERA, payload: { eraNumber } })\n  }, [])\n\n  const updateIsRecovery = useCallback((isRecovery) => {\n    dispatch({ type: UPDATE_RECOVERY, payload: { isRecovery } })\n  }, [])\n\n  const updateSlaDetail = useCallback((isRecovery) => {\n    dispatch({ type: UPDATE_SLA, payload: { isRecovery } })\n  }, [])\n\n  // Poll the hub to keep track of the Era number\n  // Can then use it as a clock to avoid excessive requests to hub\n  useEffect(() => {\n    const test = () => {\n      const { nocust } = state\n      if (nocust) {\n        console.log('Checking Era')\n        nocust.getEraNumber()\n          .then(eraNumber => {\n            console.log('Era:', eraNumber)\n            updateEra(eraNumber)\n          })\n          .catch(() => {\n            console.log('setting eraNumber to null')\n            updateEra(null)\n          })\n      }\n    }\n\n    test()\n    const intervalId = setInterval(test, 10000)\n    return () => { clearInterval(intervalId) }\n  }, [state.nocust])\n\n  return (\n    <NocustContext.Provider value={useMemo(() => [state, { updateNocust, updateEra, updateIsRecovery, updateSlaDetail }], [state, updateNocust, updateEra, updateIsRecovery, updateSlaDetail])}>\n      {children}\n    </NocustContext.Provider>\n  )\n}\n\nexport function useNocustHubInfo () {\n  const [state] = useNocustContext()\n  const { hub } = state\n\n  return hub\n}\n\nexport function getBlocksPerEon () {\n  const [state, { updateBlocksPerEon }] = useNocustContext()\n  const { nocust, blocksPerEon } = state\n\n  useEffect(() => {\n    if (nocust) {\n      nocust.getBlocksPerEon()\n        .then((blocksPerEon) => updateBlocksPerEon(blocksPerEon))\n        .catch(() => updateBlocksPerEon(null))\n    }\n  }, [nocust])\n  console.log(state)\n\n  return blocksPerEon\n}\n\n//Old NOCUST\nexport function useNocustClient () {\n  const [state, { updateNocust }] = useNocustContext()\n  const { web3, nocust } = state\n\n  useEffect(() => {\n    if (web3 && !nocust) {\n      try {\n        const nocustManager = new NOCUSTManager({\n          rpcApi: web3,\n          operatorApiUrl: HUB_API_URL,\n          contractAddress: HUB_CONTRACT_ADDRESS\n        })\n      \n        updateNocust(nocustManager)\n        console.log('new nocust-client')\n      } catch (e) {\n        updateNocust(null)\n        console.log('no nocust-client')\n      }\n    }\n  })\n\n  return nocust\n}\n\nexport function useIsRecovery () {\n  const [state, { updateIsRecovery }] = useNocustContext()\n  //const { nocust, isRecovery, eraNumber } = state\n  const { isRecovery, eraNumber, privateKey } = state\n  console.log('pk', privateKey)\n\n  useEffect(() => {\n    const checkIsRecovery = async () => {\n\n      await nocust.init({\n        contractAddress: HUB_CONTRACT_ADDRESS,\n        rpcUrl: WEB3_PROVIDER,\n        operatorUrl: HUB_API_URL\n      });\n    \n      await nocust.addPrivateKey(privateKey);\n      console.log(\"Private key added\");\n    \n      const recoveryMode = await nocust.isRecoveryMode();\n      recoveryMode.then(isRecovery => updateIsRecovery(isRecovery))\n      .catch(() => updateIsRecovery(false))\n    };\n    \n    checkIsRecovery();\n  }, [eraNumber]);\n\n  return isRecovery\n}\n\nexport function useEraNumber () {\n  const [state] = useNocustContext()\n  const { eraNumber } = state\n\n  return eraNumber\n}\n\nexport function useSlaDetail (address) {\n  const [state, { updateSlaDetail }] = useNocustContext()\n  const { nocust, eraNumber, slaDetail } = state\n\n  useEffect(() => {\n    if (nocust) {\n      nocust.getSLADetail()\n        .then((slaDetail) => updateSlaDetail(slaDetail))\n        .catch((slaDetail) => updateSlaDetail({}))\n    }\n  }, [address, eraNumber])\n\n  return slaDetail\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}