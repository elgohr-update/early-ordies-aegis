"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var store_1 = require("../store");
var blockchain_1 = require("./blockchain");
var utils_1 = require("../helpers/utils");
var ethereumjs_util_1 = require("ethereumjs-util");
var getParentChainBalance_1 = __importDefault(require("../nocust/getParentChainBalance"));
var constants_1 = require("../constants");
var DEPOSIT_GAS_LIMIT = 300000;
var WITHDRAWAL_REQUEST_GAS_LIMIT = 1000000;
var RESPONSE_GAS = 100100;
function deposit(config) {
    return __awaiter(this, void 0, void 0, function () {
        var address, token, amount, gasPrice, nonce;
        return __generator(this, function (_a) {
            address = config.address, token = config.token, amount = config.amount, gasPrice = config.gasPrice, nonce = config.nonce;
            return [2, blockchain_1.blockchain.sendNocustMethod({
                    name: 'deposit',
                    address: address,
                    params: [token, address, amount.toFixed(0)],
                    gasLimit: DEPOSIT_GAS_LIMIT,
                    gasPrice: gasPrice,
                    amount: utils_1.isSameHexValue(token, store_1.store.contractAddress) ? amount : '0',
                    nonce: nonce,
                })];
        });
    });
}
function requestWithdrawal(config) {
    return __awaiter(this, void 0, void 0, function () {
        var address, amount, gasPrice, token, walletState, data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    address = config.address, amount = config.amount, gasPrice = config.gasPrice, token = config.token, walletState = config.walletState;
                    return [4, blockchain_1.blockchain.sendNocustMethod({
                            name: 'requestWithdrawal',
                            address: address,
                            amount: bignumber_js_1.default.max(store_1.store.minChallengeGasCost.multipliedBy(RESPONSE_GAS), new bignumber_js_1.default(gasPrice).multipliedBy(RESPONSE_GAS)),
                            gasLimit: WITHDRAWAL_REQUEST_GAS_LIMIT,
                            gasPrice: gasPrice,
                            params: [
                                token,
                                [walletState.merkleProof.activeStateHash, walletState.merkleProof.passiveHash],
                                walletState.merkleProof.trail,
                                walletState.merkleProof.allotmentChain,
                                walletState.merkleProof.membershipChain,
                                walletState.merkleProof.values,
                                [
                                    [walletState.merkleProof.left, walletState.merkleProof.right],
                                    [walletState.merkleProof.passiveAmount, walletState.merkleProof.passiveMarker],
                                ],
                                amount.toFixed(0),
                            ],
                        })];
                case 1:
                    data = _a.sent();
                    return [2, data.transactionHash];
            }
        });
    });
}
function fetchBlocksPerEon() {
    return __awaiter(this, void 0, void 0, function () {
        var data, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4, blockchain_1.blockchain.callNocustMethod('BLOCKS_PER_EON')];
                case 1:
                    data = _a.sent();
                    store_1.store.blocksPerEon = parseInt(data);
                    return [3, 3];
                case 2:
                    e_1 = _a.sent();
                    return [2, Promise.reject(e_1)];
                case 3: return [2];
            }
        });
    });
}
function fetchGenesisBlock() {
    return __awaiter(this, void 0, void 0, function () {
        var data, e_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4, blockchain_1.blockchain.callNocustMethod('genesis')];
                case 1:
                    data = _a.sent();
                    store_1.store.genesisBlock = parseInt(data);
                    return [3, 3];
                case 2:
                    e_2 = _a.sent();
                    return [2, Promise.reject(e_2)];
                case 3: return [2];
            }
        });
    });
}
function fetchContractOwnerAddress() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_3;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = store_1.store;
                    return [4, blockchain_1.blockchain.callNocustMethod('operator')];
                case 1:
                    _a.contractOwner = _b.sent();
                    return [3, 3];
                case 2:
                    e_3 = _b.sent();
                    return [2, Promise.reject(e_3)];
                case 3: return [2];
            }
        });
    });
}
function fetchSlackPeriod() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_4;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = store_1.store;
                    return [4, blockchain_1.blockchain.callNocustMethod('BLOCKS_PER_EPOCH')];
                case 1:
                    _a.slackPeriod = _b.sent();
                    return [3, 3];
                case 2:
                    e_4 = _b.sent();
                    return [2, Promise.reject(e_4)];
                case 3: return [2];
            }
        });
    });
}
function fetchExtendedSlackPeriod() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_5;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = store_1.store;
                    return [4, blockchain_1.blockchain.callNocustMethod('EXTENDED_BLOCKS_PER_EPOCH')];
                case 1:
                    _a.extendedSlackPeriod = _b.sent();
                    return [3, 3];
                case 2:
                    e_5 = _b.sent();
                    return [2, Promise.reject(e_5)];
                case 3: return [2];
            }
        });
    });
}
function fetchEonsKept() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_6;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = store_1.store;
                    return [4, blockchain_1.blockchain.callNocustMethod('EONS_KEPT')];
                case 1:
                    _a.eonsKept = _b.sent();
                    return [3, 3];
                case 2:
                    e_6 = _b.sent();
                    return [2, Promise.reject(e_6)];
                case 3: return [2];
            }
        });
    });
}
function fetchDepositsKept() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_7;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = store_1.store;
                    return [4, blockchain_1.blockchain.callNocustMethod('DEPOSITS_KEPT')];
                case 1:
                    _a.depositsKept = _b.sent();
                    return [3, 3];
                case 2:
                    e_7 = _b.sent();
                    return [2, Promise.reject(e_7)];
                case 3: return [2];
            }
        });
    });
}
var checkOutstandingChallenges = function () {
    return blockchain_1.blockchain.callNocustMethod('hasOutstandingChallenges');
};
var checkMissedCheckpointSubmission = function () {
    return blockchain_1.blockchain.callNocustMethod('hasMissedCheckpointSubmission');
};
var checkIsWalletRecovered = function (address, token) {
    return blockchain_1.blockchain.callNocustMethod('getIsWalletRecovered', [token, address]);
};
var getLastSubmissionEon = function () { return blockchain_1.blockchain.callNocustMethod('lastSubmissionEon'); };
var getDepositsSumAtEon = function (address, token, eon) {
    return blockchain_1.blockchain.callNocustMethod('getDepositsAtEon', [token, address, eon]);
};
var fetchMinChallengeGasCost = function () { return __awaiter(void 0, void 0, void 0, function () {
    var value, e_8;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, blockchain_1.blockchain.callNocustMethod('MIN_CHALLENGE_GAS_COST')];
            case 1:
                value = _a.sent();
                store_1.store.minChallengeGasCost = new bignumber_js_1.default(value);
                return [3, 3];
            case 2:
                e_8 = _a.sent();
                return [2, Promise.reject(e_8)];
            case 3: return [2];
        }
    });
}); };
var getWalletChallenges = function (address, token) {
    return blockchain_1.blockchain.callNocustMethod('getChallenge', [token, address, address]);
};
var submitInitialMerkleStateChallenge = function (config) { return __awaiter(void 0, void 0, void 0, function () {
    var txSetHash, challengeName, challengeParams;
    return __generator(this, function (_a) {
        try {
            txSetHash = config.walletState.merkleProof.activeState
                ? config.walletState.merkleProof.activeState.txSetHash
                : constants_1.EMPTY_HASH;
            challengeName = 'challengeStateUpdateWithProofOfExclusiveBalanceAllotment';
            challengeParams = [
                config.proof.token,
                [config.walletState.merkleProof.activeStateHash, config.walletState.merkleProof.passiveHash],
                config.walletState.merkleProof.trail,
                config.walletState.merkleProof.allotmentChain,
                config.walletState.merkleProof.membershipChain,
                config.walletState.merkleProof.values,
                [
                    [config.walletState.merkleProof.left, config.walletState.merkleProof.right],
                    [config.spent.toFixed(0), config.gained.toFixed(0)],
                    [
                        config.walletState.merkleProof.passiveAmount,
                        config.walletState.merkleProof.passiveMarker,
                    ],
                ],
                [
                    ethereumjs_util_1.addHexPrefix(config.operatorSignature.r),
                    ethereumjs_util_1.addHexPrefix(config.operatorSignature.s),
                    txSetHash,
                ],
                ethereumjs_util_1.addHexPrefix(config.operatorSignature.v),
            ];
            console.log('challengeParams', challengeParams);
            return [2, blockchain_1.blockchain.sendNocustMethod({
                    name: challengeName,
                    address: config.address,
                    amount: bignumber_js_1.default.max(store_1.store.minChallengeGasCost.multipliedBy(config.gas), config.gasPrice.multipliedBy(config.gas)),
                    gasPrice: config.gasPrice.toFixed(0),
                    gasLimit: config.gas,
                    params: challengeParams,
                })];
        }
        catch (e) {
            return [2, Promise.reject(e)];
        }
        return [2];
    });
}); };
var submitInitialEmptyStateChallenge = function (config) { return __awaiter(void 0, void 0, void 0, function () {
    var txSetHash, challengeName, challengeParams;
    return __generator(this, function (_a) {
        try {
            txSetHash = config.walletState.merkleProof.activeState
                ? config.walletState.merkleProof.activeState.txSetHash
                : constants_1.EMPTY_HASH;
            challengeName = 'challengeStateUpdateWithProofOfActiveStateUpdateAgreement';
            challengeParams = [
                config.token,
                txSetHash,
                config.trailIdentifier,
                [config.spent.toFixed(0), config.gained.toFixed(0)],
                ethereumjs_util_1.addHexPrefix(config.operatorSignature.r),
                ethereumjs_util_1.addHexPrefix(config.operatorSignature.s),
                ethereumjs_util_1.addHexPrefix(config.operatorSignature.v),
            ];
            return [2, blockchain_1.blockchain.sendNocustMethod({
                    name: challengeName,
                    address: config.address,
                    amount: bignumber_js_1.default.max(store_1.store.minChallengeGasCost.multipliedBy(config.gas), config.gasPrice.multipliedBy(config.gas)),
                    gasPrice: config.gasPrice.toFixed(0),
                    gasLimit: config.gas,
                    params: challengeParams,
                })];
        }
        catch (e) {
            return [2, Promise.reject(e)];
        }
        return [2];
    });
}); };
var submitDeliveryChallenge = function (config) { return __awaiter(void 0, void 0, void 0, function () {
    var tokenAddress, address, senderAddress, recipientAddress, nonce, senderTrailIdentifier, transferMembershipTrail, recipientTrailIdentifier, chain, txSetRoot, spent, gained, amount, operatorSignature, gasPrice, gas, balance, challengeName, challengeParams, responseReimbursement, e_9;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 3, , 4]);
                tokenAddress = config.tokenAddress, address = config.address, senderAddress = config.senderAddress, recipientAddress = config.recipientAddress, nonce = config.nonce, senderTrailIdentifier = config.senderTrailIdentifier, transferMembershipTrail = config.transferMembershipTrail, recipientTrailIdentifier = config.recipientTrailIdentifier, chain = config.chain, txSetRoot = config.txSetRoot, spent = config.spent, gained = config.gained, amount = config.amount, operatorSignature = config.operatorSignature, gasPrice = config.gasPrice, gas = config.gas;
                return [4, getParentChainBalance_1.default(address)];
            case 1:
                balance = _a.sent();
                challengeName = 'challengeTransferDeliveryWithProofOfActiveStateUpdateAgreement';
                challengeParams = [
                    ethereumjs_util_1.addHexPrefix(tokenAddress),
                    [ethereumjs_util_1.addHexPrefix(senderAddress), ethereumjs_util_1.addHexPrefix(recipientAddress)],
                    [nonce.toFixed(0), amount.toFixed(0)],
                    [senderTrailIdentifier, transferMembershipTrail, recipientTrailIdentifier],
                    chain.map(function (x) { return ethereumjs_util_1.addHexPrefix(x); }),
                    [spent.toFixed(0), gained.toFixed(0)],
                    [
                        ethereumjs_util_1.addHexPrefix(operatorSignature.r),
                        ethereumjs_util_1.addHexPrefix(operatorSignature.s),
                        ethereumjs_util_1.addHexPrefix(txSetRoot),
                    ],
                    ethereumjs_util_1.addHexPrefix(operatorSignature.v),
                ];
                return [4, blockchain_1.blockchain.estimateGasOfNocustMethod(challengeName, address, balance.toFixed(0), challengeParams)];
            case 2:
                responseReimbursement = _a.sent();
                return [2, blockchain_1.blockchain.sendNocustMethod({
                        name: challengeName,
                        address: config.address,
                        amount: store_1.store.minChallengeGasCost.multipliedBy(responseReimbursement),
                        gasPrice: gasPrice.toFixed(0),
                        gasLimit: gas,
                        params: challengeParams,
                    })];
            case 3:
                e_9 = _a.sent();
                return [2, Promise.reject(e_9)];
            case 4: return [2];
        }
    });
}); };
var recoverAllFunds = function (config) { return __awaiter(void 0, void 0, void 0, function () {
    var recoverParams;
    return __generator(this, function (_a) {
        try {
            recoverParams = [
                config.token,
                config.address,
                [config.activeStateChecksum, config.passiveChecksum],
                config.trail,
                config.allotmentChain,
                config.membershipChain,
                config.values.map(function (x) { return x.toFixed(0); }),
                [config.left.toFixed(0), config.right.toFixed(0)],
                ['0', config.passiveAmount.toFixed(0), config.passiveMarker.toFixed(0)],
            ];
            return [2, blockchain_1.blockchain.sendNocustMethod({
                    name: 'recoverAllFunds',
                    address: config.address,
                    gasPrice: config.gasPrice.toFixed(0),
                    gasLimit: config.gas,
                    params: recoverParams,
                })];
        }
        catch (e) {
            return [2, Promise.reject(e)];
        }
        return [2];
    });
}); };
exports.contracts = {
    checkMissedCheckpointSubmission: checkMissedCheckpointSubmission,
    checkOutstandingChallenges: checkOutstandingChallenges,
    deposit: deposit,
    fetchBlocksPerEon: fetchBlocksPerEon,
    fetchContractOwnerAddress: fetchContractOwnerAddress,
    fetchGenesisBlock: fetchGenesisBlock,
    getDepositsSumAtEon: getDepositsSumAtEon,
    fetchMinChallengeGasCost: fetchMinChallengeGasCost,
    requestWithdrawal: requestWithdrawal,
    getWalletChallenges: getWalletChallenges,
    fetchSlackPeriod: fetchSlackPeriod,
    fetchExtendedSlackPeriod: fetchExtendedSlackPeriod,
    fetchEonsKept: fetchEonsKept,
    fetchDepositsKept: fetchDepositsKept,
    submitInitialMerkleStateChallenge: submitInitialMerkleStateChallenge,
    submitInitialEmptyStateChallenge: submitInitialEmptyStateChallenge,
    submitDeliveryChallenge: submitDeliveryChallenge,
    recoverAllFunds: recoverAllFunds,
    getLastSubmissionEon: getLastSubmissionEon,
    checkIsWalletRecovered: checkIsWalletRecovered,
};
//# sourceMappingURL=contracts.js.map